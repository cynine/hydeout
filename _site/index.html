<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Cynine &middot; 个人博客
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/hydeout/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/hydeout/favicon.png" />
<link rel="shortcut icon" href="/hydeout/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/hydeout/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="index home">

    <div id="sidebar">
  <header>
    <h1 class="site-title">
      <a href="/hydeout/">
        
        Cynine
      </a>
    </h1>
    <p class="lead">Everything I do now, is in pursuit of more perfect.</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link  active"
        href="/hydeout/">Home</a>
  
  

  

  


  
    
  

  
    
  

  
    
  

  
    
  

  
    
      <a class="page-link "
          href="/hydeout/about">About</a>
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  

  
    
  


  


  
    
  

  
    
      <a class="category-link "
          href="/hydeout/category/Developer">开发笔记</a>
    
  

  
    
      <a class="category-link "
          href="/hydeout/category/Flutter">Flutter</a>
    
  

  
    
      <a class="category-link "
          href="/hydeout/category/Python">Python</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/hydeout/category/iOS">iOS</a>
    
  

  
    
  

  

  
    
  

  
    
  

  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  
    <a id="github-link"
       class="icon" title="Github Project" aria-label="Github Project"
       href="https://github.com/Cynine/hydeout">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 28" height="24" width="28"><path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</svg>

    </a>
    <a id="github-download-link"
       class="icon" title="Download" aria-label="Download"
       href="https://github.com/Cynine/hydeout/archive/v4.0.2.zip">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/hydeout/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/hydeout/tags">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/hydeout/search">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>

  <p>
  &copy; 2020.
  <a href="/hydeout/LICENSE.md">MIT License.</a>
</p>

</div>

    <main class="container">
      <div class="content">
  


  

  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/hydeout/2020/03/01/block.html">
        Blocks
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">01 Mar 2020</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/hydeout/category/iOS">
          iOS
        </a>
      
    
  </span>
</div>


    
      <h2 id="blocks-知识点">Blocks 知识点</h2>
<p><img src="assets/images/15835447426404.jpg" alt="img" /></p>

<h2 id="前言">前言</h2>
<ul>
  <li>block的原理是怎样的？本质是什么？</li>
  <li>__block的作用是什么？有什么使用注意点？</li>
  <li>block的属性修饰词为什么是copy？使用block有哪些使用注意？</li>
  <li>block在修改NSMutableArray，需不需要添加__block？</li>
</ul>

<h2 id="1-blocks-概要">1. Blocks 概要</h2>
<h3 id="11-什么是-blocks">1.1 什么是 Blocks</h3>

<p>Blocks 是 C 语言的扩充功能，即：<strong>带有自动变量（局部变量）的匿名函数</strong>。</p>
<ul>
  <li>“带有自动变量”：为保证 Blocks 能正常访问外部的变量，Blocks 有一个自动捕获变量的机制。Blocks 能自动捕获（保存）在其内部使用到的外部自动变量（局部变量）的<strong>瞬间值</strong>。</li>
  <li>匿名函数:不带有名称的函数。</li>
</ul>

<p>其他语言中 Block 的名称</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">程序语言</th>
      <th style="text-align: center">Block 的名称</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">C + Blocks</td>
      <td style="text-align: center">Block</td>
    </tr>
    <tr>
      <td style="text-align: center">Smalltalk</td>
      <td style="text-align: center">Block</td>
    </tr>
    <tr>
      <td style="text-align: center">Ruby</td>
      <td style="text-align: center">Block</td>
    </tr>
    <tr>
      <td style="text-align: center">LISP</td>
      <td style="text-align: center">Block</td>
    </tr>
    <tr>
      <td style="text-align: center">Python</td>
      <td style="text-align: center">Lambda</td>
    </tr>
    <tr>
      <td style="text-align: center">C++ 11</td>
      <td style="text-align: center">Lambda</td>
    </tr>
    <tr>
      <td style="text-align: center">JavaScript</td>
      <td style="text-align: center">Anonymous fucntion</td>
    </tr>
  </tbody>
</table>

<h2 id="2-block-模式">2. Block 模式</h2>
<h3 id="21-block-语法">2.1 Block 语法</h3>
<p>完整形式的 Block 语法与一般的 C 语言函数定义相比，仅有两点不同：</p>
<ol>
  <li>没有函数名: 因为 Block 是匿名函数。</li>
  <li>带有“\^” （插入记号，caret）记号: 因为 OS X、iOS 应用程序的源代码中将大量使用 Block，所以插入该记好便于查找。</li>
</ol>

<p>Block 声明语法:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^ 返回值类型 参数列表 表达式

e.g:
^int (int count) { return count + 1; };
</code></pre></div></div>
<p>Block 语法的简化：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 省略返回值类型（表达式含有 return 语句时，其返回值类型必定与 return 返回值的类型一致）

^ 参数列表 表达式

e.g:
^(int count) { return count + 1; };

2. 省略返回值类型和参数列表

^表达式

e.g:
^{ return count + 1 };
</code></pre></div></div>
<h3 id="22-block-类型变量">2.2 Block 类型变量</h3>

<p>Block 语法但从记述方式来看，除了没有名称和带有“\^”以外，其他的都与 C 语言函数定义相同。在定义 C 语言函数时，可以将定义函数的地址赋值给函数指针变量中。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">funcptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">;</span>
</code></pre></div></div>

<p>在 Block 的语法下，可将 Block 语法赋值给声明为 Block 类型的变量中。即源代码中一旦使用 Block 语法就相当于生成了可赋值给 Block 类型变量的“值”。在 Blocks 中，“Block” 既指源代码中的 Block 语法，也指由 Block 语法所生成的值。
声明 Block 类型变量：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>
<p>与前面对比使用函数指针的源代码对比，声明 Block 类型变量仅仅是将声明函数指针类型变量的 “*” 变成了 “\^”。该 Block 类型变量的与一般的 C 语言变量完成相同，可做为以下用途使用:</p>
<ul>
  <li>自动变量</li>
  <li>函数参数</li>
  <li>静态变量</li>
  <li>静态全局变量</li>
  <li>全局变量
使用 Block 语法将 Block 赋值为 Block 类型变量:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div>
<ul>
  <li>由 Block 类型变量向 Block 类型变量赋值：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk1</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">blk</span><span class="p">;</span>

<span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk2</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">blk2</span> <span class="o">=</span> <span class="n">blk1</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>将 Block 类型变量作为函数参数使用：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>
<ul>
  <li>将 Block 作为函数的返回值返回：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">func</span><span class="p">())(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">){</span><span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;};</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>使用 <code class="highlighter-rouge">typedef</code> 简化上述操作：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* 原来的记述方式 
void func(int (^blk)(int))
*/</span>

<span class="err">简化为：</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">blk_t</span> <span class="n">blk</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/* 原来的记述方式
int (^func()(int))
*/</span>

<span class="err">简化为：</span>
<span class="n">blk_t</span> <span class="n">func</span><span class="p">()</span>
</code></pre></div></div>
<p>将赋值给 Block 类型变量中的 Block 方法的调用与使用函数指针类型变量调用函数的方法几乎完全相同：</p>
<ul>
  <li>调用函数指针类型变量:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">funcptr</span><span class="p">)(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>调用 Block 类型变量:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">blk</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>
<p>Block 类型变量调用 Block 与 C 语言通常的函数调用没有区别。在函数参数重使用 Block 类型变量并在函数中执行 Block 的例子:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="n">blk_t</span> <span class="n">blk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">blk</span><span class="p">(</span><span class="n">rete</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在 Objective-C 中方法使用:</p>

<div class="language-objectivec highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">methodUsingBlock</span><span class="p">:(</span><span class="n">blk_t</span><span class="p">)</span><span class="nv">blk</span> <span class="nf">rete</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="nv">rete</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">blk</span><span class="p">(</span><span class="n">rete</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Block 类型变量可完全像通常的 C 语言变量一样使用，因此也可以使用之乡 Block 类型变量的指针，即 Block 的指针类型变量:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

<span class="n">blk_t</span> <span class="n">blk</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">){</span><span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>

<span class="n">blk_t</span> <span class="o">*</span><span class="n">blkprt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">blk</span><span class="p">;</span>

<span class="p">(</span><span class="o">*</span><span class="n">blkptr</span><span class="p">)(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>
<h3 id="23-截获自动变量值">2.3 截获自动变量值</h3>
<p>“带有自动变量值”在 Blocks 中表现为“截获自动变量值”。截获自动变量值的实例如下:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">dmy</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="s">"val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);};</span>
    
    <span class="n">val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="s">"Thes values were changed. val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    
    <span class="n">bll</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// val = 10</span>
</code></pre></div></div>
<p>在该代码中， Block 语法的表达式使用的是它之前声明的自动变量 fmt 和 val。Blocks 中，Block 表达式截获所使用的自动变量值，即保存该自动变量的<strong>瞬间值</strong>。在执行 Block 语法后，即使改写 Block 中使用的自动变量的值也不会影响 Block 执行时变量的值。该 Block 语法执行时，字符串指针 “val=%d\n”被赋值到自动变量 fmt 中，int 值 10 被赋值到自动变量 val 中，因此这些值被保存（即被截获），从而在执行块时使用。<strong>这就是自动变量值的捕获</strong>。</p>

<h3 id="24-__block-说明符">2.4 __block 说明符</h3>
<p>若想在 Block 语法的表达式中将赋给 Block 语法外声明的自动变量，需要在该自动变量上附加 <code class="highlighter-rouge">__block</code> 说明符。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>

<span class="n">blk</span><span class="p">();</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

<span class="c1">// val = 1</span>
</code></pre></div></div>
<p>使用附有 <code class="highlighter-rouge">__block</code> 说明符的自动变量可在 Block 中赋值，<strong>该变量称为 __block 变量</strong>。</p>
<h2 id="3-blocks-的实现">3 Blocks 的实现</h2>
<h3 id="31-block-的实质">3.1 Block 的实质</h3>
<p>通过 clang（LLVM 编译器）将 Objective-C 源代码转换为 C++ 的源代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -rewrite-objc 源代码文件名
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span> <span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="p">};</span>

    <span class="n">blk</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>通过 clang 将上述代码转换成 C++ 代码得：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__block_impl</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> 
    <span class="mi">0</span><span class="p">,</span> 
    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">));</span>

    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对比最初的源代码中的 Block 语法：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">)};</span>
</code></pre></div></div>

<p>转换为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>如转换的源代码所示，通过 Blocks 使用的匿名函数实际上被作为简单的 C 语言函数来处理。另外，根据 Block 语法所属的函数名（此处为main）和该 Block 语法在该函数出现的顺序值（此处为0）来经 clang 变换的函数命名。</p>

<p><code class="highlighter-rouge">__cself</code> 相当于 C++ 实例方法中指向实例自身的变量 <code class="highlighter-rouge">this</code>，或是 Objective-C 实例方法中指向对象自身的变量 <code class="highlighter-rouge">self</code>, 即参数 <code class="highlighter-rouge">__cself</code> 为指向 Block 值的变量。<code class="highlighter-rouge">__cself</code> 声明如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span>
</code></pre></div></div>

<p>与 C++ 的 this 和 Objective-C 的 self 相同， 参数 __cself 是 __main_block_impl_0 结构题的指针。该结构体声明如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span> <span class="c1">// 今后版本升级所需的区域以及函数指针</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span> <span class="c1">// 其结构为今后版本升级所需要区域和 Block 的大小</span>
<span class="p">};</span>	
</code></pre></div></div>

<p><strong>__block_impl</strong> 结构体的声明：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__block_impl</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span> 
  <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>__main_block_desc_0</strong> 结构体声明：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>再看 <strong>__main_block_impl_0</strong> 结构的构造函数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span> 
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该构造函数的调用：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> 
  <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">(</span>
     <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">));</span>
</code></pre></div></div>

<p>去掉强制转化部分，可得：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__mian_block_impl_0</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">__main_block_impl_0</span><span class="p">(</span>
     <span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
</code></pre></div></div>

<p>该代码将 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体类型的自动变量，即栈上生成的 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例的指针，赋值给 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体指针类型的变量 <code class="highlighter-rouge">blk</code>。这部分最初的源代码为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="o">^</span> <span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="p">};</span>	
</code></pre></div></div>

<p>将 Block 语法生成的 Block 赋值给 Block 类型的变量 blk。等同于将 <code class="highlighter-rouge">__main_block_impl_0</code>  结构体实例的指针赋值给 <code class="highlighter-rouge">blk</code>。该源代码中的 Block 就是 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体类型的自动变量，即栈上生成的 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例。</p>

<p>由 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体源代码可得，该结构体的构造函数的构造参数为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__main_block_impl_0</span><span class="p">(</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">);</span>
</code></pre></div></div>

<p>第一个参数是由 Block 语法转换的 C 语言函数指针。第二个参数是作为静态全局变量初始化的 <code class="highlighter-rouge">__main_block_desc_0</code> 结构体实例指针。以下是 <code class="highlighter-rouge">__main_block_desc_0</code>  结构体实例的初始化部分代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span>  <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> 
    <span class="mi">0</span><span class="p">,</span> 
    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由此可知，该源代码使用 Block， 即 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体的实例的大小，进行初始化。</p>

<p>栈上 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例（即 Block）参数的初始化过程：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 展开 __main_block_impl_0 结构体的 __block_impl 结构体</span>
<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span> 
  <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span> 
<span class="p">};</span>	
</code></pre></div></div>

<p>该构造体根据构造函数会像下面这样进行初始化：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span> 
<span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">__main_block_func_0</span><span class="p">;</span>
<span class="n">Desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">;</span>
</code></pre></div></div>

<p>再看 Block 调用部分源代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">blk</span><span class="p">();</span>
</code></pre></div></div>

<p>这部分可转换为以下源代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>
</code></pre></div></div>

<p>去掉转换部分：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(*blk-&gt;impl.FuncPtr)(blk);
</code></pre></div></div>

<p>这就是简单地使用函数指针调用函数。由 Block 语法转换的 <code class="highlighter-rouge">__main_block_func_0</code> 函数的指针被赋值给成员变量 FuncPtr 中。另外说明了，<code class="highlighter-rouge">__main_block_func_0</code> 函数的参数 <code class="highlighter-rouge">__cself</code> 指向 Block 值。在调用该函数的源代码中可以看出 Block 正式作为参数进行了传递。</p>

<p>至此总算是摸清了 Block 的实质，不过之前跳过没有说明的 <code class="highlighter-rouge">_NSConcreteStackBlock</code> 到底是什么。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>isa = &amp;_NSConcreteStackBlock; 
</code></pre></div></div>

<p>将 Block 指针赋给 Block 的结构体成员变量 isa。为了理解它，首先要理解 Objective-C 类和对象的实质。其实，<strong>所谓 Block 就是 Objective-C 对象</strong>。</p>

<h3 id="32-截获自动变量值">3.2 截获自动变量值</h3>

<div class="language-objectivec highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="err">@autoreleasepool</span> <span class="p">{</span>
        
        <span class="kt">int</span> <span class="n">dmy</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="s">"val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        
        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);};</span>
        
        <span class="n">blk</span><span class="p">();</span>
        
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>通过 clang 转换可得：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  
  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_fmt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">fmt</span><span class="p">(</span><span class="n">_fmt</span><span class="p">),</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// bound by copy</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by copy</span>
<span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span> 

        <span class="kt">int</span> <span class="n">dmy</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="s">"val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>

        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Block 语法表达式中使用的自动变量被作为成员变量追加到了 <code class="highlighter-rouge">__main_block_impl_0</code>结构体中。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">__main_block_impl_0</code> 结构体内声明的成员变量类型与自动变量类型完全相同（只有在 Block 语法表达式中使用的自动变量才会被追加）。<strong>Block 的自动变量捕获只针对 Block 使用的自动变量</strong>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_fmt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">fmt</span><span class="p">(</span><span class="n">_fmt</span><span class="p">),</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div>

<p>在初始化结构体时，根据传递给构造函数的参数对自动变量追加的成员变量进行初始化。以下通过构造函数调用确认其参数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> 
  <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
</code></pre></div></div>

<p>使用执行 Block 语法时的自动变量 fmt 和 val 来初始化 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例。即在该源代码中，<code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例的初始化如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>impl.isa = &amp;_NSConcreteStackBlock;
impl.Flags = 0;
impl.FuncPtr = __main_block_func_0;
Desc = &amp;__main_block_desc_0_DATA;
fmt = "val = %d\n";
val = 10;
</code></pre></div></div>

<p>由此可知，在 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例（即Block） 中，自动变量值被捕获。</p>

<p>下面再看一下使用 Block 的匿名函数的实现。最初源代码的 Block 语法如下所示：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);}</span>
</code></pre></div></div>

<p>该源代码可转换以下函数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// bound by copy</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by copy</span>
	<span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在转换后的源代码中，截获到 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例的成员变量上的自动变量，这些变量在 Block 语法表达式之前被声明定义。因此，原来的源代码表达式无需改动便可使用截获的自动变量值执行。</p>

<p>总的来说，所谓“截获自动变量值”意味着在执行 Block 语法时，Block 语法表达式所使用的自动变量值被保存到 Block 的结构体实例（即Block自身）中。需要注意的是，Block 不能直接使用 C 语言数组类型的自动变量。</p>

<h3 id="33-__block-说明符">3.3 __block 说明符</h3>

<p>Block 中所使用的被截获自动变量就如“带有自动变量值的匿名函数”所说，仅截获自动变量的值。Block 中使用自动变量后，在 Block 的结构体实例中重写该自动变量也不会改变原先截获的自动变量。</p>

<p>在 C 语言中有个一个变量允许 Block 改写值：</p>

<ul>
  <li>静态变量</li>
  <li>静态全局变量</li>
  <li>全局变量</li>
</ul>

<div class="language-objectivec highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">global_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">static_global_val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="err">@autoreleasepool</span> <span class="p">{</span>
        
        <span class="k">static</span> <span class="kt">int</span> <span class="n">static_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        
        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">global_val</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">static_global_val</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">static_val</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">};</span>
        
        <span class="n">blk</span><span class="p">();</span>
        
        <span class="n">printf</span><span class="p">(</span><span class="s">"global_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">global_val</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"static_global_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">static_global_val</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"static_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">static_val</span><span class="p">);</span>
        
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该源代码转换后如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">global_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">static_global_val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">static_val</span><span class="p">;</span>
  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">_static_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">static_val</span><span class="p">(</span><span class="n">_static_val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">static_val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">static_val</span><span class="p">;</span> <span class="c1">// bound by copy</span>

            <span class="n">global_val</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">static_global_val</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="p">(</span><span class="o">*</span><span class="n">static_val</span><span class="p">)</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span> 

        <span class="k">static</span> <span class="kt">int</span> <span class="n">static_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">static_val</span><span class="p">));</span>

        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"global_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">global_val</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"static_global_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">static_global_val</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"static_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">static_val</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由此可见访问静态全局变量 <code class="highlighter-rouge">static_global_val</code> 和全局变量 <code class="highlighter-rouge">global_val</code> 与转换前完全相同。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">static_val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">static_val</span><span class="p">;</span> <span class="c1">// bound by copy</span>

						<span class="p">...</span>
            <span class="p">(</span><span class="o">*</span><span class="n">static_val</span><span class="p">)</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>对于静态变量 <code class="highlighter-rouge">static_val</code>, 使用静态变量 <code class="highlighter-rouge">static_val</code>的指针对其进行访问。将静态变量 <code class="highlighter-rouge">static_val</code> 的<strong>指针</strong>传递给 <code class="highlighter-rouge">__main_block_impl_0</code>结构体的构造函数并保存。</p>

<p>静态变量的这种方法似乎也适用于自动变量的访问。但为什么没有这么做呢？</p>

<p>实际上，在由 Block 语法生成的值 Block 上，可以存有超过其变量作用域的被截获对象的自动变量。变量作用域结束的同时，原来的自动变量被废弃，因此 Block 中超过变量作用于而存在的变量同静态变量一样，将不能通过指针访问原来的自动变量。</p>

<p>解决 Block 中不能保存值这一问题的第二种方法是使用 <strong>__block</strong> 说明符。在 C 语言中有以下存储域类说明符：</p>

<ul>
  <li>typedef</li>
  <li>extern</li>
  <li>static</li>
  <li>auto</li>
  <li>register</li>
</ul>

<p>__block 说明符类似于 static 、auto 和 register 说明符，它们用于指定将变量值设置到哪个存储域中。例如，auto 表示作为自动变量存储在栈中，static 表示作为静态变量存储在数据区中。</p>

<p>__block 使用如下：</p>

<div class="language-objectivec highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="err">@autoreleasepool</span> <span class="p">{</span>
        
        <span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;};</span>
        
        <span class="n">blk</span><span class="p">();</span>
        
        <span class="n">printf</span><span class="p">(</span><span class="s">"val=%d"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>转换后如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__Block_byref_val_0</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
<span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span> <span class="c1">// by ref</span>
  
  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by ref</span>
<span class="p">(</span><span class="n">val</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">),</span> <span class="n">__main_block_copy_0</span><span class="p">,</span> <span class="n">__main_block_dispose_0</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span> 

        <span class="c1">//__attribute__((__blocks__(byref))) __Block_byref_val_0 val = {(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10};</span>
        <span class="n">__Block_byref_val_0</span> <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
          <span class="mi">0</span><span class="p">,</span>
          <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> 
          <span class="mi">0</span><span class="p">,</span> 
          <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_val_0</span><span class="p">),</span> 
          <span class="mi">10</span>
        <span class="p">};</span>               
                        
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>

        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"val=%d"</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">));</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由以上源码可得变量 val 上附加了 __block 说明符之后：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="c1">// 经过转换</span>
<span class="k">struct</span> <span class="n">__Block_byref_val_0</span> <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span>
  <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_val_0</span><span class="p">),</span>
  <span class="mi">10</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">__block</code> 变量变为了结构体实例。<code class="highlighter-rouge">__block</code> 变量也同 Block 一样变成 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体类型的自动变量，即栈上生成的 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体实例。该变量初始化为10，且这个值也出现在结构体实例的初始化中，这意味着该结构体持有相当于原自动变量的成员变量。该结构体声明如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__Block_byref_val_0</span> <span class="p">{</span>
 <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
 <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>如同初始化时的源代码，该结构体中最后的成员变量 val 是相当于原自动变量的成员变量，从它的名称也能看出这一点。</p>

<p>再来看给 __block 变量赋值的代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^{val = 1;}
</code></pre></div></div>

<p>转换如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by ref</span>
	<span class="p">(</span><span class="n">val</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>刚刚在 Block 中向静态变量赋值时，使用了指向该静态变量的指针。而向 <code class="highlighter-rouge">__block</code> 变量赋值过程中，Block 的<code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例持有指向 <code class="highlighter-rouge">__block</code> 变量 val 的 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体实例的指针。</p>

<p><code class="highlighter-rouge">__Block_byref_val_0</code> 结构体实例的成员变量 <code class="highlighter-rouge">__forwarding</code> 持有指向该实例自身的指针。通过成员变量 <code class="highlighter-rouge">__forwarding</code> 访问成员变量 val（成员变量 val 时该实例自身持有的变量，它相当于原自动变量）。</p>

<p><img src="assets/images/image-20200307190818557.png" alt="img" /></p>

<p>另外, <code class="highlighter-rouge">__block</code> 变量的 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体并不在 Block 中的 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体中，这样做是为了在多个 Block 中使用 <code class="highlighter-rouge">__Block</code>变量。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        
<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk0</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;};</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk1</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;};</span>
</code></pre></div></div>

<p>Block 类型变量 blk0 和 blk1 访问 <code class="highlighter-rouge">__block</code> 变量 val。这部分代码转换后如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__Block_byref_val_0</span> <span class="n">val</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_val_0</span><span class="p">),</span> <span class="mi">10</span><span class="p">};</span>

<span class="n">blk0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">(</span>
  <span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>

<span class="n">blk1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_impl_1</span><span class="p">(</span>
  <span class="n">__main_block_func_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_1_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>
</code></pre></div></div>

<p>两个 Block 都是用了 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体实例 val 的指针。这样一来就可以从多个 Block 中使用同一个 <code class="highlighter-rouge">__block</code> 变量。当然，反过来从一个 Block 中使用多个 <code class="highlighter-rouge">__block</code> 变量也是可以的。只要增加 Block 的结构体成员变量与构造函数的参数，便可对应使用多个 <code class="highlighter-rouge">__block</code> 变量。</p>


    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/hydeout/2020/01/17/flutter-widget.html">
        Widget 知识点
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">17 Jan 2020</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/hydeout/category/Flutter">
          Flutter
        </a>
      
    
  </span>
</div>


    
      <p><img src="https://flutter.dev/assets/resources/diagram-layercake-73512ded89f7df8301f622c66178633f04f91187822daf1ddff0d54b2d2676dc.png" alt="图1 Flutter 架构图" /></p>

<h3 id="问题">问题</h3>

<ul>
  <li>什么是 Widget ?</li>
  <li>如何理解 Widget 、Element 和 RenderObject 这三个概念？它们之间是一一对应的吗？能否在 Android/iOS/Web 中找到对应的概念呢？</li>
</ul>

<p>在 iOS 中 UIView 相当于 Element, CALayer 相当于 RenderObject. UIKit 没有 Widget 这个概念。</p>

<h3 id="概念">概念</h3>

<p><strong>Flutter 的核心设计思想是”一切 Widget”</strong>。</p>

<p>Widget 是 Flutter 功能的抽象描述，是视图的配置信息，同样也是数据的映射，是 Flutter 开发框架中最基本的概念。如 View, View Controller, Activity, Application, Layout等，在 Flutter 中都是 Widget。</p>

<h3 id="widget-渲染过程">Widget 渲染过程</h3>

<p>Flutter 将视图树的概念进行了扩展，把视图数据的组织和渲染抽象为三部分，即 Widget，Element 和 RenderObject。这三部分之间的关系，如下所示：</p>

<p><img src="https://static001.geekbang.org/resource/image/b4/c9/b4ae98fe5b4c9a7a784c916fd140bbc9.png" alt="img" /></p>

<h3 id="widget">Widget</h3>

<p>Widget 是 Flutter 世界里对视图的一种结构化描述，可看作前端中的“控件”或“组件”。Widget 是控件实现的基本逻辑单位，里面存储的是有关视图渲染的配置信息，包括布局、渲染属性、事件响应信息等。</p>

<p>在页面渲染上，Flutter 将“Simple is best”这一理念做到了极致。Flutter 将 Widget 设计成不可变的，所以当视图渲染的配置信息发生变化时，Flutter 会选择重建 Widget 树的方式进行数据更新，以数据驱动 UI 构建的方式简单高效。但这样做的缺点是，因为涉及到大量对象的销毁和重建，所以会对垃圾回收造成压力。不过，Widget 本身并不涉及实际渲染位图，所以它只是一份轻量级的数据结构，重建的成本很低。</p>

<p>另外，由于 Widget 的不可变性，可以以较低成本进行渲染节点复用，因此在一个真实的渲染树中可能存在不同的 Widget 对应同一个渲染节点的情况，这无疑又降低了重建 UI 的成本。</p>

<h3 id="element">Element</h3>

<p>Element 是 Widget 的一个实例化对象，它承载了视图构建的上下文数据，是连接结构化的配置信息到完成最终渲染的桥梁。</p>

<p>Flutter 渲染过程，可以分为这么三步：</p>
<ul>
  <li>首先，通过 Widget 树生成对应的 Element 树；</li>
  <li>然后，创建相应的 RenderObject 并关联到 Element.renderObject 属性上；</li>
  <li>最后，构建成 RenderObject 树，以完成最终的渲染。</li>
</ul>

<p>可以看到，Element 同时持有 Widget 和 RenderObject。而无论是 Widget 还是 Element，其实都不负责最后的渲染，只负责发号施令，真正去干活儿的只有 RenderObject。那么，为什么不直接 Widget 命令 RenderObject 去干活呢？因为这样会极大增加渲染带来的性能损耗。因为 Widget 具有不可变性，但 Element 却是可变的。实际上，Element 树这一层将 Widget 树的变化（类似 React 虚拟 DOM diff）做了抽象，可以只将真正需要修改的部分同步到真实的 RenderObject 树中，最大程度降低对真实渲染视图的修改，提高渲染效率，而不是销毁整个渲染视图树重建。这，就是 Element 树存在的意义。</p>

<h3 id="renderobject">RenderObject</h3>

<p>RenderObject 是主要负责实现视图渲染的对象。渲染对象树在 Flutter 的展示过程分为四个阶段，即布局、绘制、合成和渲染。其中，布局和绘制在 RenderObject 中完成，Flutter 采用深度优先机制遍历渲染对象树，确定树中各个对象的位置和尺寸，并把它们绘制到不同的图层上。绘制完毕后，合成和渲染的工作则交给 Skia 搞定。</p>

<p><strong>Flutter 通过引入 Widget、Element 与 RenderObject 这三个概念，把原本从视图数据到视图渲染的复杂构建过程拆分得更简单、直接，在易于集中治理的同时，保证了较高的渲染效率。</strong></p>

<h3 id="renderobjectwidget">RenderObjectWidget</h3>

<p>在 Flutter 中，布局和绘制工作实际上是在 Widget 的另一个子类 RenderObjectWidget 内完成的。</p>

<p>RenderObjectWidget 的源码如下:</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RenderObjectWidget</span> <span class="kd">extends</span> <span class="n">Widget</span> <span class="o">{</span>
  <span class="nd">@override</span>
  <span class="n">RenderObjectElement</span> <span class="n">createElement</span><span class="o">();</span>
  <span class="nd">@protected</span>
  <span class="n">RenderObject</span> <span class="n">createRenderObject</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">);</span>
  <span class="nd">@protected</span>
  <span class="kt">void</span> <span class="n">updateRenderObject</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">covariant</span> <span class="n">RenderObject</span> <span class="n">renderObject</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>RenderObjectWidget 是一个抽象类。我们通过源码可以看到，这个类中同时拥有创建 Element、RenderObject，以及更新 RenderObject 的方法。实际上，RenderObjectWidget 本身并不负责这些对象的创建与更新。</p>

<p>对于 Element 的创建，Flutter 会在遍历 Widget 树时，调用 createElement 去同步 Widget 自身配置，从而生成对应节点的 Element 对象。而对于 RenderObject 的创建与更新，其实是在 RenderObjectElement 类中完成的。</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RenderObjectElement</span> <span class="kd">extends</span> <span class="n">Element</span> <span class="o">{</span>
  <span class="n">RenderObject</span> <span class="n">_renderObject</span><span class="o">;</span>

  <span class="nd">@override</span>
  <span class="kt">void</span> <span class="n">mount</span><span class="o">(</span><span class="n">Element</span> <span class="n">parent</span><span class="o">,</span> <span class="kd">dynamic</span> <span class="n">newSlot</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">super</span><span class="o">.</span><span class="na">mount</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">newSlot</span><span class="o">);</span>
    <span class="n">_renderObject</span> <span class="o">=</span> <span class="n">widget</span><span class="o">.</span><span class="na">createRenderObject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="n">attachRenderObject</span><span class="o">(</span><span class="n">newSlot</span><span class="o">);</span>
    <span class="n">_dirty</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
   
  <span class="nd">@override</span>
  <span class="kt">void</span> <span class="n">update</span><span class="o">(</span><span class="n">covariant</span> <span class="n">RenderObjectWidget</span> <span class="n">newWidget</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">super</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">newWidget</span><span class="o">);</span>
    <span class="n">widget</span><span class="o">.</span><span class="na">updateRenderObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">renderObject</span><span class="o">);</span>
    <span class="n">_dirty</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在 Element 创建完毕后，Flutter 会调用 Element 的 mount 方法。在这个方法里，会完成与之关联的 RenderObject 对象的创建，以及与渲染树的插入工作，插入到渲染树后的 Element 就可以显示到屏幕中了。</p>

<p>如果 Widget 的配置数据发生了改变，那么持有该 Widget 的 Element 节点也会被标记为 dirty。在下一个周期的绘制时，Flutter 就会触发 Element 树的更新，并使用最新的 Widget 数据更新自身以及关联的 RenderObject 对象，接下来便会进入 Layout 和 Paint 的流程。而真正的绘制和布局过程，则完全交由 RenderObject 完成：</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RenderObject</span> <span class="kd">extends</span> <span class="n">AbstractNode</span> <span class="k">with</span> <span class="n">DiagnosticableTreeMixin</span> <span class="kd">implements</span> <span class="n">HitTestTarget</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="kt">void</span> <span class="n">layout</span><span class="o">(</span><span class="n">Constraints</span> <span class="n">constraints</span><span class="o">,</span> <span class="o">{</span> <span class="kt">bool</span> <span class="n">parentUsesSize</span> <span class="o">=</span> <span class="kc">false</span> <span class="o">})</span> <span class="o">{...}</span>
  
  <span class="kt">void</span> <span class="n">paint</span><span class="o">(</span><span class="n">PaintingContext</span> <span class="n">context</span><span class="o">,</span> <span class="n">Offset</span> <span class="n">offset</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>布局和绘制完成后，接下来的事情就交给 Skia 了。在 VSync 信号同步时直接从渲染树合成 Bitmap，然后提交给 GPU。</p>

<h3 id="总结">总结</h3>

<p>Flutter 中视图数据的组织和渲染抽象的三个核心概念: Widget 、Element 和 RenderObject。</p>

<p>Widget 是 Flutter 世界里对视图的一种结构化描述，里面存储的是有关视图渲染的配置信息；Element 则是 Widget 的一个实例化对象，将 Widget 树的变化做了抽象，能够做到只将真正需要修改的部分同步到真实的 Render Object 树中，最大程度地优化了从结构化的配置信息到完成最终渲染的过程；而 RenderObject，则负责实现视图的最终呈现，通过布局、绘制完成界面的展示。</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/hydeout/2020/01/14/ios-map.html">
        iOS 开发舆图
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">14 Jan 2020</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/hydeout/category/iOS">
          iOS
        </a>
      
    
  </span>
</div>


    
      <blockquote>
  <p>原文出处: <a href="http://www.starming.com/2019/07/29/ios-map/">星光社-戴铭的博客-iOS开发舆图</a></p>
</blockquote>

<p><img src="http://www.starming.com/uploads/ios-map/1.png" alt="img" /></p>

<p><img src="http://www.starming.com/uploads/ios-map/2.png" alt="img" /></p>

<p><img src="http://www.starming.com/uploads/ios-map/3.png" alt="img" /></p>

<p><img src="http://www.starming.com/uploads/ios-map/4.png" alt="img" /></p>

<p><img src="http://www.starming.com/uploads/ios-map/5.png" alt="img" /></p>

<p><img src="http://www.starming.com/uploads/ios-map/6.png" alt="img" /></p>

<h2 id="实例">实例</h2>

<p>学习 iOS 开发最好是从学习一个完整的 App 入手，GitHub上的<a href="https://github.com/dkhamsing/open-source-ios-apps">Open-Source iOS Apps</a>
项目，收录了大量开源的完整 App 例子，比如 <a href="https://github.com/Dimillian/SwiftHN">Hacker News Reader</a> 等已经上架了 App Store 的应用程序，所有例子都会标注是否上架 App Store的、所使用开发语言、推荐等级等信息，有利于进行选择学习。</p>

<p>开发一个完整的 App 也有最佳实践，这里有份<a href="https://github.com/futurice/ios-good-practices">最佳实践</a>可以参考。</p>

<p>下面两个教程网站都会手把手通过实例教你怎么动手学习 iOS 各个知识点。</p>

<ol>
  <li><a href="https://www.appcoda.com/">AppCoda</a> <a href="https://www.appcoda.com.tw/">中文网</a></li>
  <li><a href="https://www.raywenderlich.com/library">Raywenderlich</a></li>
</ol>

<h2 id="ios-基础">iOS 基础</h2>

<p>完整开发了多个 App 后，为了更好、更快的掌握开发，你就会有需要了解更多 iOS 基础知识的诉求，包括列表的优化、高效界面布局开发、图表图形、图片处理、动画多媒体等等。</p>

<p>图形渲染 Metal 框架的学习可以参看下面四篇文章</p>

<ol>
  <li><a href="https://objccn.io/issue-18-2/">Metal</a></li>
  <li><a href="https://juejin.im/post/5a225ffcf265da432153daa4">基于 Metal 的 ARKit 使用指南（上）</a></li>
  <li><a href="https://juejin.im/post/59bb2a99f265da0650750e56">基于 Metal 的 ARKit 使用指南（下）</a></li>
  <li><a href="https://xiaozhuanlan.com/topic/6927418053">基于 Metal 的现代渲染技术</a></li>
</ol>

<h2 id="ios-系统">iOS 系统</h2>

<p>iOS 基础学习到一定程度就需要了解 App 是如何在系统中工作的，系统提供了什么基础功能，提供了哪些界面控件等等。</p>

<p>扩展知识可以阅读下面四本书：</p>

<ol>
  <li>《深入解析Mac OS X &amp; iOS操作系统》</li>
  <li>《现代操作系统》</li>
  <li>《深入理解计算机系统》</li>
  <li>《程序员的自我修养》</li>
</ol>

<h2 id="编程语言">编程语言</h2>

<p>编程语言的学习可以参考官方手册，对于 Runtime 的扩展文章阅读：</p>

<ol>
  <li><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></li>
  <li><a href="https://halfrost.com/objc_runtime_isa_class/">神经病院Objective-C Runtime入院第一天——isa和Class</a>（ <a href="https://halfrost.com/objc_runtime_isa_class/">https://halfrost.com/objc_runtime_isa_class/</a> ）</li>
  <li><a href="https://halfrost.com/objc_runtime_objc_msgsend/">神经病院 Objective-C Runtime 住院第二天——消息发送与转发</a></li>
  <li><a href="https://halfrost.com/how_to_use_runtime/">神经病院 Objective-C Runtime 出院第三天——如何正确使用</a></li>
</ol>

<p>编程语言 Swift 推荐阅读书籍是《Swift 进阶》、《函数式Swift》。大量Swift Playground 可以了解 Swift 编程语言的特性，这里有份整理 <a href="https://github.com/uraimo/Awesome-Swift-Playgrounds">GitHub - uraimo/Awesome-Swift-Playgrounds: A List of Awesome Swift Playgrounds</a> 。这份资料汇总了 SwiftUI 的资料 <a href="https://github.com/Juanpe/About-SwiftUI">GitHub - Juanpe/About-SwiftUI: Gathering all info published, both by Apple and by others, about new framework SwiftUI.</a> 。这里有本在线书详细讲解了 Combine
<a href="https://heckj.github.io/swiftui-notes/">《Using Combine》</a> 。</p>

<p>架构相关扩展阅读可以参看 <a href="https://kangzubin.com/ios-component-articles/">iOS 组件化相关讨论文章汇总 KANGZUBIN</a> 。</p>

<p>设计模式推荐书籍如下：</p>

<ul>
  <li>《设计模式 可复用面向对象软件的基础》</li>
  <li>《Objective-C 编程之道：iOS设计模式解析》</li>
  <li>《Head First 设计模式》</li>
  <li>《大话设计模式》</li>
</ul>

<h2 id="开发工具">开发工具</h2>

<p>开发的代码多了，开发效率和开发质量的提升就越来越离不开开发工具了。</p>

<p>iOS 开发工具 Xcode、Instrument 的使用学习，推荐看苹果开发者大会 WWDC 的 Session 视频。</p>

<p>扩展阅读文章推荐：</p>

<ol>
  <li><a href="http://www.aosabook.org/en/llvm.html">The Architecture of Open Source Application</a></li>
  <li><a href="https://manu343726.github.io/2017-02-11-writing-ast-matchers-for-libclang/">Writing AST matchers for libclang</a></li>
  <li><a href="http://yulingtianxia.com/blog/2019/01/27/MVVM-Rules-for-OCLint/">使用 OCLint 自定义 MVVM 规则</a></li>
  <li><a href="https://mp.weixin.qq.com/s/vCzUNHyLfjQKF23Biq9z-g">iOS 增量代码覆盖率检测实践</a></li>
</ol>

<p>阅读书籍推荐：</p>

<ol>
  <li>《Getting Started with LLVM Core Libraries》</li>
  <li>《Modern Compiler Implementation in C》</li>
  <li>《Compiler》</li>
</ol>

<h2 id="开发完成">开发完成</h2>

<p>当开发完成后就需要进行调试、持续化交付、测试。</p>

<p>LLDB 调试推荐先看<a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html">官方指南</a>，再看这篇<a href="https://objccn.io/issue-19-2/">“与调试器共舞 - LLDB 的华尔兹”</a>。为了更好的调试体验扩展 LLDB 可以参看这篇文章<a href="https://pspdfkit.com/blog/2018/how-to-extend-lldb-to-provide-a-better-debugging-experience/">“How to Extend LLDB to Provide a Better Debugging Experience”</a>。</p>

<p>另外，这个<a href="https://github.com/MattPD/cpplinks/blob/master/debugging.md">网址</a>收录了各种调试资料。</p>

<p>持续化交付可以参看各大公司的实践，比如：</p>

<ol>
  <li><a href="https://zhuanlan.zhihu.com/p/69526642">知乎 iOS 客户端工程化工具 - Venom</a></li>
  <li><a href="https://mp.weixin.qq.com/s/Oa52PvsHw8wS-OvYb3ArZg">百度App iOS工程化实践: EasyBox破冰之旅</a></li>
  <li><a href="https://mp.weixin.qq.com/s/6WAq_fM0znjO5eY12vjxFw">如何实现“持续集成”？淘系闲鱼把研发效率翻了个翻</a></li>
</ol>

<p>测试扩展阅读推荐文章如下：</p>

<ol>
  <li><a href="https://onevcat.com/2014/02/ios-test-with-kiwi/">TDD的iOS开发初步以及Kiwi使用入门</a></li>
  <li><a href="https://onevcat.com/2014/05/kiwi-mock-stub-test/">Kiwi 使用进阶 Mock, Stub, 参数捕获和异步测试</a></li>
  <li><a href="https://nshipster.com/unit-testing/">Unit Testing</a></li>
  <li><a href="https://tech.meituan.com/2017/06/23/mobile-app-automation.html">客户端自动化测试研究</a></li>
  <li><a href="https://mp.weixin.qq.com/s/5rt-uxApK-MeKYn0eKLVcQ?from_safari=1&amp;scene=40#wechat_redirect">PICK一下，iOS自动化测试新方案出道</a></li>
  <li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247488757&amp;idx=1&amp;sn=22465225abd30e56181ad68cdcb60e88&amp;chksm=e8fcc21ddf8b4b0bc97126bb41d95ab8df24c9db20eb9b6efd36ba969ce2e1df000b702ef639&amp;mpshare=1&amp;scene=1&amp;srcid=0221Rpn12CYSXPIE0D1ndrNi&amp;pass_ticket=QDFhyHIsSuU8LkeDk3P%2Bsli%2FL%2BwfD5Y55dNIk2PcCwbawmrDVExKHNGlflrh0dhL#rd">爱奇艺基于AI的移动端自动化测试框架的设计</a></li>
</ol>

<h2 id="上线后">上线后</h2>

<p>开发完成后，做完测试，就可以上线了。上线后还需要做大量监控保证用户使用 App 的高可用性和好体验。动态化保证发版灵活和问题的快速修复。</p>

<p>推荐的扩展阅读如下：</p>

<ol>
  <li><a href="https://everettjf.github.io/2018/08/06/ios-launch-performance-collection/">iOS应用启动性能优化资料</a></li>
  <li><a href="http://www.zoomfeng.com/blog/launch-time.html">iOS启动时间优化</a></li>
  <li><a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html">Understanding and Analyzing Application Crash Reports</a></li>
  <li><a href="http://www.zoomfeng.com/blog/plcrashreporter-1.html">PLCrashreporter源码分析其一</a></li>
  <li><a href="http://www.zoomfeng.com/blog/plcrashreporter-2.html">PLCrashreporter源码分析其二</a></li>
  <li><a href="https://inessential.com/hownottocrash">How Not to Crash</a></li>
  <li><a href="https://mp.weixin.qq.com/s/XM4bhncHzRFB7zMJa-g2-Q">Logan：美团点评的开源移动端基础日志库</a></li>
  <li><a href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/">Hook Objective-C Block with Libffi</a></li>
  <li><a href="https://www.fireeye.com/blog/threat-research/2016/01/hot_or_not_the_bene.html">Hot or Not? The Benefits and Risks of iOS Remote Hot Patching</a></li>
</ol>

<h2 id="计算机基础">计算机基础</h2>

<p>经历多次 App 开发到上线后的过程，碰到问题，解决问题，越发觉得计算机基础的重要性。牢固的基础能有利于碰到问题时快速定位和解决。</p>

<p>推荐扩展阅读文章和资源如下：</p>

<ol>
  <li><a href="https://github.com/raywenderlich/swift-algorithm-club">Algorithms and data structures in Swift, with explanations!</a></li>
  <li><a href="https://developer.apple.com/videos/play/wwdc2018/416/">iOS Memory Deep Dive</a></li>
  <li><a href="https://developer.apple.com/videos/play/wwdc2012/242/">iOS App Performance: Memory</a></li>
  <li><a href="http://newosxbook.com/articles/MemoryPressure.html">No pressure, Mon! Handling low memory conditions in iOS and Mavericks</a></li>
  <li><a href="https://swift.gg/2017/09/07/friday-qa-2015-09-04-lets-build-dispatch_queue/">从零构建 Dispatch Queue</a></li>
  <li><a href="http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/">Threading Programming Guide(1)</a></li>
  <li><a href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/">Threading Programming Guide(2)</a></li>
  <li><a href="http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/">Threading Programming Guide(3)</a></li>
  <li><a href="https://swift.gg/2018/06/07/friday-qa-2015-02-06-locks-thread-safety-and-swift/">Swift 中的锁和线程安全</a></li>
  <li><a href="http://satanwoo.github.io/2016/10/23/multithread-dangling-pointer/">浅谈一种解决多线程野指针的新思路</a></li>
  <li><a href="https://bestswifter.com/deep-gcd/">深入理解 GCD</a></li>
  <li><a href="https://xiaozhuanlan.com/Grand-Central-Dispatch">深入浅出GCD</a></li>
  <li><a href="http://mrpeak.cn/blog/ios-runloop/">解密 Runloop</a></li>
  <li><a href="https://mp.weixin.qq.com/s/gPZnR7sF_22KSsqepohgNg">Matrix-iOS 卡顿监控</a></li>
</ol>

<h2 id="通用知识">通用知识</h2>

<p>iOS 开发中还有很多和其他计算机领域相通的知识，比如渲染、数据库、网络等。</p>

<p>推荐扩展阅读文章有：</p>

<ol>
  <li><a href="https://lision.me/ios_rendering_process/">深入理解 iOS Rendering Process</a></li>
  <li><a href="https://objccn.io/issue-3-1/">绘制像素到屏幕上</a></li>
  <li><a href="https://swift.gg/2017/04/25/how-do-I-build-a-network-layer/">手把手教你封装网络层</a></li>
  <li><a href="https://github.com/Ikiga/IkigaJSON">A high performance JSON library in Swift</a></li>
</ol>

<p>网络相关文章推荐如下：</p>

<ol>
  <li><a href="https://mp.weixin.qq.com/s/BIfya6eVaWZW9ZEVz8RRcg">百度App网络深度优化系列《三》弱网优化</a></li>
  <li><a href="http://zhoulingyu.com/2018/05/30/ios-network-traffic/">iOS 流量监控分析 周小鱼のCODE_HOME</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-1.md">TCP/IP（一）：数据链路层</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-2.md">TCP/IP（二）：IP 协议</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-3.md">TCP/IP（三）：IP 协议相关技术</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-4.md">TCP/IP（四）：TCP 与 UDP 协议简介</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-5.md">TCP/IP（五）：TCP 协议详解</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-6.md">TCP/IP（六）：HTTP 与 HTTPS 简介</a></li>
  <li><a href="http://chuansong.me/n/2577464">携程App的网络性能优化实践</a></li>
  <li><a href="http://tech.meituan.com/SharkSDK.html">美团点评移动网络优化实践</a></li>
  <li><a href="http://course.tuicool.com/course/details/58058f15a826b5f9e86678fb">万人低头时代，支付宝APP无线网络性能该如何保障</a></li>
  <li><a href="https://mp.weixin.qq.com/s/qD9-Xj0CEil0Wtwq5eiPTg">QQ空间在生产环境使用QUIC协议的经验</a></li>
  <li><a href="https://mp.weixin.qq.com/s/mRcz8o0usoqm_cEoGg9btg">美图HTTPS优化探索与实践</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/https-9-questions.md">九个问题从入门到熟悉 HTTPS</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/quic.md">试图取代 TCP 的 QUIC 协议到底是什么</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/http-encoding.md">小谈 HTTP 中的编码</a></li>
  <li><a href="https://github.com/bestswifter/blog/blob/master/articles/wireshark.md">利用 WireShark 深入调试网络请求</a></li>
  <li><a href="https://juejin.im/post/59caf86ef265da06484467e5">关于 iOS HTTP2.0 的一次学习实践 - 掘金</a></li>
  <li><a href="http://blog.cnbang.net/tech/3531/">移动 APP 网络优化概述 « bang’s blog</a></li>
  <li><a href="http://wereadteam.github.io/2016/02/25/GYHttpMock/">GYHttpMock：iOS HTTP请求模拟工具 WeRead团队博客</a></li>
  <li><a href="https://knightsj.github.io/2017/07/18/YTKNetwork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">YTKNetwork源码解析 J<em>Knight</em></a></li>
  <li><a href="[https://github.com/lefex/LefexWork/blob/master/blog/iOS/iOS](https://github.com/lefex/LefexWork/blob/master/blog/iOS/iOS) 需要掌握的 HTTP [知识.md](http://xn--k7y073b.md/)">LefexWork/iOS 需要掌握的 HTTP [知识.md](http://xn–k7y073b.md/) at master · lefex/LefexWork · GitHub</a></li>
  <li><a href="https://github.com/lefex/LefexWork/blob/master/blog/iOS/%E4%BB%A5%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3SDWebImage.md">LefexWork/以不一样的方式理解SDWebImage.md at master · lefex/LefexWork · GitHub</a></li>
  <li><a href="https://blog.csdn.net/Hello_Hwc/article/details/72853786">Alamofire的设计之道 - Leo的专栏 - CSDN博客</a></li>
</ol>

<h2 id="专有知识">专有知识</h2>

<p>专有知识我就不展开说了，参考上面舆图中标注的知识点去检索你需要的就可以了。</p>

<h2 id="视野">视野</h2>

<p>推荐手册：</p>

<ol>
  <li><a href="https://developer.apple.com/documentation/">Apple Developer Documentation</a></li>
  <li><a href="https://swiftgg.gitbook.io/swift/huan-ying-shi-yong-swift">Swift 开发手册</a></li>
</ol>

<p>开源控件：</p>

<ol>
  <li><a href="https://iosexample.com/">iOS Example</a></li>
  <li><a href="https://www.cocoacontrols.com/">Cocoa Controls</a></li>
  <li><a href="https://github.com/matteocrippa/awesome-swift">awesome-swift</a></li>
  <li><a href="https://xiaozhuanlan.com/topic/5796328014">Swift 开源项目精选 - 应用架构角度</a></li>
  <li><a href="https://xiaozhuanlan.com/topic/5271086934">Swift 开源项目精选导图</a></li>
  <li><a href="https://github.com/ipader/SwiftGuide">SwiftGuide</a></li>
  <li><a href="https://xiaozhuanlan.com/topic/7314260859">Swift 开源项目团队介绍</a></li>
  <li><a href="https://xiaozhuanlan.com/topic/9687124530">Swift 知名开发者介绍</a></li>
</ol>

<p>视频推荐 <a href="https://talk.objc.io/">Swift Talk - objc.io</a> 。</p>

<p>这里的 iOS 博客都很值得订阅，<a href="https://github.com/awesome-tips/blogs">GitHub - awesome-tips/blogs: 行业优质博客汇总</a>。</p>

<p>其他资源参看上面的地图。</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/hydeout/2020/01/13/swift-project-open-libs.html">
        🚀 Swift 项目中的开源库
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">13 Jan 2020</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/hydeout/category/iOS">
          iOS
        </a>
      
    
  </span>
</div>


    
      <blockquote>
  <p>本文出处: <a href="https://github.com/SwiftOldDriver/SwiftMarch">SwiftOldDriver/SwiftMarch</a>
并在这个基础上进行扩充。</p>
</blockquote>

<h1 id="swiftmarch"><strong>SwiftMarch</strong></h1>

<p>Swift 发展趋势喜人，Github 上已经有很多相关的开源项目，也有一些人进行了收集。然而我们如何判断某个开源库能否安心的在项目中使用呢？毕竟不是谁都有时间或者能力读完全部的源码，有些库即使读了源码也无法立刻得出是是否可以大规模的应用。</p>

<p>因此，我们决定作出一点努力。我们会筛选出<strong>广泛应用于实际 Swift 项目</strong>的开源库，并且从一线开发者中搜集相关的评价。如果你打算开始一个 Swift 项目，希望这里面的信息对你有帮助。</p>

<p>如果你觉得某个开源库很棒而我们遗漏了可以开 PR 给我们，或者对我们公布的某些库有独到的评价可以通过 PR 告诉我们，我们会尽快处理。</p>

<h1 id="目录"><strong>目录</strong></h1>

<h2 id="网络"><strong>网络</strong></h2>

<h3 id="alamofire"><strong><a href="https://github.com/Alamofire/Alamofire">Alamofire</a></strong></h3>

<p>Swift 中使用最广泛的网络库。由大神 matt 负责，值得信赖。可以看介绍：<a href="https://github.com/ipader/SwiftGuide/wiki/%E5%85%A8%E8%BA%AB%E5%BF%83%E6%8B%A5%E6%8A%B1%E5%BC%80%E6%BA%90%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85-Mattt-Thompson">全身心拥抱开源的开发者 Mattt Thompson</a>。需要提醒的是 4.1.0 的版本支持 iOS 8 ， 4.0 的版本只支持 iOS 9 。</p>

<h3 id="moya"><a href="https://github.com/Moya/Moya"><strong>Moya</strong></a></h3>

<p>Swift 编写的网络抽象性层框架。Moya 的基本思想是，提供一些网络抽象层，它们经过充分地封装，并直接调用 Alamofire。</p>

<h3 id="promisekit"><a href="https://github.com/mxcl/PromiseKit">PromiseKit</a></h3>

<p>PromiseKit is a thoughtful and complete implementation of promises for any platform that has a swiftc</p>

<h3 id="tiercel"><a href="https://github.com/Danie1s/Tiercel">Tiercel</a></h3>

<p>纯 Swift 的下载框架，文档清晰，代码整洁。支持多任务并发、大文件下载和断点续传等特点，满足下载的大部分需求。</p>

<h2 id="json-解析"><strong>JSON 解析</strong></h2>

<h3 id="swiftyjson"><strong><a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJSON</a></strong></h3>

<p>SwiftyJSON 应该算是最老牌的 JSON 解析库之一，安全快捷又不啰嗦。知道的人多，用的人多，星星也多。对于嵌套复杂的 JSON 数据依然能够如字典取值般简单；灵活地与 <code class="highlighter-rouge">if let</code> 配合使用，更不用担心取到了错误的数据。</p>

<h3 id="objectmapper"><strong><a href="https://github.com/Hearst-DD/ObjectMapper">ObjectMapper</a></strong></h3>

<p>JSON 解析是 iOS 开发中再常见不过的了，也许你只听过上面星星很多的 SwiftyJSON，但是我相信你用过 ObjectMapper 后一定会喜欢上它的。首先 ObjectMapper 使用起来非常简洁，配合 <a href="https://github.com/Ahmed-Ali/JSONExport">JSON Export</a> 使用，你完全不需要在嵌套的 JSON 数据里摸不着北，它还支持结构体和自定义转换。同时，ObjectMapper 还遵守面向协议编程的范式，你的 Model 只需要实现 Mappable 协议就可以了，这会让你的代码更 Swifty。如果你想让你的 Model 看起来既优雅又清爽，那么我建议你一定要试一试这个库。</p>

<p>这是 ObjectMapper 的<a href="https://github.com/lacklock/ObjectMapper-CN-Guide">中文文档翻译</a>。</p>

<h2 id="存储"><strong>存储</strong></h2>

<h3 id="yycache"><strong><a href="https://github.com/ibireme/YYCache">YYCache</a></strong></h3>

<p>轻量级缓存的最可靠选择。不得不承认的一个事实是目前没有一个用 Swift 编写的优秀缓存库。最流行的 Haneke 作者在 2.3 版本后已经放弃维护，当然本身 Haneke 的实现也不算优秀。虽然 OC 中的基本数据对象在 Swift 中使用需要经过类型转换，但是经过实际测试这部分性能损失在日常业务处理中并没有多大的影响，属于可以接受的范围。</p>

<p>具体设计介绍参考作者写的：<a href="http://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路与技术细节</a>。</p>

<h3 id="realm"><strong><a href="https://realm.io/cn">Realm</a></strong></h3>

<p>Realm 是由硅谷创业公司发布的一款可以用于 iOS 和 Android 的跨平台移动数据库。支持的平台包括 Java，Objective-C，Swift，React Native，Xamarin。是第一个专门针对移动平台的数据库，立志取代 SQLite 、CoreData。核心数据引擎由 C++ 开发，有着优异的性能。简单易用可以快速上手，在数据存储时再也不用思考烦人的底层技术细节。</p>

<p>基于技术选型的限制，目前 Realm 使用中也有一些明显的不便：</p>

<ul>
  <li>
    <p>Realm 没有自动增长属性</p>

    <p>Realm 没有线程/进程安全的自动增长属性机制，这在其他数据库中常常用来产生主键</p>
  </li>
  <li>所有的数据模型必须直接继承自 RealmObject 。这阻碍我们利用数据模型中的任意类型的继承。以下是不能完成的：
    <ul>
      <li>多态类之间的转换（例如子类转换成子类，子类转换成父类，父类转换成子类等）</li>
      <li>同时对多个类进行检索</li>
      <li>多类容器 (RLMArray 以及 RLMResults)</li>
    </ul>
  </li>
  <li>NSData 以及 NSString 属性不能保存超过 16 MB 大小的数据</li>
  <li>
    <p>不能自定义 getter、setter</p>

    <p>realm会自动生成 getter、setter ，如果自定义 getter 、setter 存储就会有影响。如果要规避这个问题，可以通过设置这个对象的忽略属性。</p>
  </li>
  <li>
    <p>查询的结果不是数组</p>

    <p>为了能够支持查询结果的链式查询，realm 自定义了一个集合类型。可以枚举，但是不是熟悉的数组了。又因为realm的懒加载机制，所以不建议在数据层把这个枚举转成数组类型。这样的缺点就是上层知道了数据的存储逻辑。严格的说这里不应该让上层知道。但是这样设计也许是为了方便上层进行再次检索，realm有着优越的查询性能。</p>
  </li>
  <li>尽管 Realm 文件可以被多个线程同时访问，但是您不能跨线程处理 Realms、Realm 对象、查询和查询结果</li>
  <li>Realm不能支持原生的集合类型，比如：NSArray 、NSDictionary 、NSSet 等。需要使用 Realm 里面提供的集合类型 RLMArray(OC)，List(Swift)</li>
</ul>

<p>关于 Realm 的基本情况介绍，可以看这篇文章：<a href="http://www.jianshu.com/p/2b4388cf2a2d">移动端数据库新王者：realm</a>。</p>

<p><strong>关于 Realm 的详细使用</strong>，可以查看<a href="https://realm.io/docs/swift/latest/">官方文档</a>。</p>

<p>更多的具体分析，请前往<a href="http://www.jianshu.com/p/50e0efb66bdf">Realm数据库 从入门到“放弃”</a>。</p>

<h2 id="图片存储"><strong>图片存储</strong></h2>

<h3 id="kingfisher"><strong><a href="https://github.com/onevcat/Kingfisher">Kingfisher</a></strong></h3>

<p>Kingfisher 是 Swift 中使用比较广泛的图片存储库。由喵神 onevcat 开源及维护。 Kingfisher 轻量级，纯 Swift 编写，目的是为了解决从网络上下载图片和缓存图片的问题。Kingfisher 的灵感主要来源于 SDWebImage，采用的存储机制和 SDWebImage一样，所以性能上没有太大区别，然而却有着更加灵活友好的 API。</p>

<p>目前支持 iOS 8.0+ / macOS 10.10+ / tvOS 9.0+ / watchOS 2.0+，Swift 3 (Kingfisher 3.x), Swift 2.3 (Kingfisher 2.x)。</p>

<p>关于 Kingfisher 的使用，详细请看这篇<a href="https://github.com/onevcat/Kingfisher/wiki">文档</a>。</p>

<h2 id="布局"><strong>布局</strong></h2>

<h3 id="snapkit"><strong><a href="https://github.com/SnapKit/SnapKit">SnapKit</a></strong></h3>

<p>如果你使用 Autolayout 布局，Snapkit 就是最好的第三方库。完整的提供了底层的能力。创造性的引入链式编程，让使用起来非常的方便。</p>

<h2 id="ui"><strong>UI</strong></h2>

<h3 id="reusable"><strong><a href="https://github.com/AliSoftware/Reusable">Reusable</a></strong></h3>

<p>UITableView 必备。更加优雅的实现 Cell 的 Register 和 Reuse 。使用参考：<a href="http://www.jianshu.com/p/255e02337176">Reusable-让你放肆的dequeueReusableCell</a>。</p>

<h3 id="dznemptydataset"><a href="https://github.com/dzenbot/DZNEmptyDataSet">DZNEmptyDataSet</a></h3>

<p>DZNEmptyDataSet 是基于 UITableView／UICollectionView 的范畴/扩展（category）类，它可以在空白页面上显示提示信息。</p>

<h2 id="util"><strong>Util</strong></h2>

<h3 id="swiftdate"><strong><a href="https://github.com/malcommac/SwiftDate">SwiftDate</a></strong></h3>

<p>非常好用的帮助处理 Date 相关的库。灵活运用了 swift 的重载操作符、扩展等特性，使得时间可以直观的进行算术运算：比较大小，直接加减等。常见的时间也字符串的转换也做了良好的支持。</p>

<h3 id="monkeyking"><strong><a href="https://github.com/nixzhu/MonkeyKing">MonkeyKing</a></strong></h3>

<p>MonkeyKing 帮助开发者快速集成国内主流社交应用(微信、微博、QQ、支付宝)的分享、授权、支付等功能。重要的是，不需要集成各种官方 SDK。目前由 4 名程序员维护。可用于生产环境、轻量级，能满足绝大部分的分享、授权、支付等需求。</p>

<h3 id="ezswiftextensions"><strong><a href="https://github.com/goktugyil/EZSwiftExtensions">EZSwiftExtensions</a></strong></h3>

<p>提供了一系列对于 Swift 标准库、方法与 UIKit 的扩展，让你更加简单舒服地编写代码。</p>

<h3 id="rswift"><strong><a href="https://github.com/mac-cain13/R.swift">R.swift</a></strong></h3>

<p>配置稍微有一点复杂，然而付出的努力对于项目而言是值得的。R.swfit 会根据项目文件在编译期生成各种资源文件的枚举，比如 nib 、UIImage 等。大幅度减少了使用资源文件时输入字符串的这种痛苦。有一个缺点就是这个库只适合使用在纯 Swift 项目中。可以参考：<a href="http://www.jianshu.com/p/b453b78c7126">R.swift:以一种优雅安全的方式使用资源文件</a>。</p>

<h3 id="swiftyattributes"><strong><a href="https://github.com/eddiekaiger/SwiftyAttributes">SwiftyAttributes</a></strong></h3>

<p>先进的 API ，操作 attributed 字符串的利器。</p>

<h3 id="nsobject_rx"><a href="https://github.com/RxSwiftCommunity/NSObject-Rx">NSObject_Rx</a></h3>

<p>Handy RxSwift extensions on NSObject, including rx.disposeBag.</p>

<h3 id="then"><a href="https://github.com/devxoul/Then">Then</a></h3>

<p>✨ Super sweet syntactic sugar for Swift initializers</p>

<h3 id="fspagerview">🐎 <a href="https://github.com/WenchaoD/FSPagerView">FSPagerView</a></h3>

<p><a href="https://github.com/GesanTung">@老峰</a>：FSPagerView 是一个 Swift 实现的优雅轮播图库，它可以在制作横幅视图、产品展示、欢迎 / 指南页面、屏幕 / 视图控制器滑块等为我们带来很大的便利。</p>

<h2 id="动画">动画</h2>

<h3 id="lottie-ios"><a href="https://github.com/airbnb/lottie-ios">lottie-ios</a></h3>

<p>An iOS library to natively render After Effects vector animations <a href="http://airbnb.io/lottie/">http://airbnb.io/lottie/</a></p>

<h3 id="hero"><a href="https://github.com/HeroTransitions/Hero">Hero</a></h3>

<p>iOS &amp; tvOS 优雅的过渡动画库</p>

<h2 id="加密"><strong>加密</strong></h2>

<h3 id="cryptoswift"><strong><a href="https://github.com/krzyzanowskim/CryptoSwift">CryptoSwift</a></strong></h3>

<p>非常流行的加密解密库，项目配有完善的单元测试，可以放心使用。</p>

<h3 id="keychainaccess"><strong><a href="https://github.com/kishikawakatsumi/KeychainAccess">KeychainAccess</a></strong></h3>

<p>轻量级 Keychain 封装,简单到极致的接口。支持 TouchID 与 Keychain 整合，详细、优雅、简明的 README。Objective-C 版本在<a href="https://github.com/soffes/SAMKeychain">这里</a></p>

<h2 id="debug"><strong>Debug</strong></h2>

<h3 id="xcglogger"><strong><a href="https://github.com/DaveWoodCom/XCGLogger">XCGLogger</a></strong></h3>

<p>由于 Swift 本身不包含 C 的预编译器，导致开发者不能使用在 OC 中定义过的宏定义进行调试打印。简单的打印调用栈的信息，又会漏掉很多有用信息。想要解决这个问题又需要加入更多的代码。基于这个目的， XCGLogger 给纯的 Swift 项目带来了解决方案。 XCGLogger 允许你在控制台记录任何细节，使用起来极其简单，和使用 nslog() 或 print() 一样方便。 XCGLogger 可以打印任何信息，甚至可以打印日期、函数名、文件名和行号等等。</p>

<h3 id="cocoalumberjack"><strong><a href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack</a></strong></h3>

<p>OC 时代最好用的记录日志的开源库。现在同时有 OC 版和 swift 版本提供。</p>

<h2 id="自动化"><strong>自动化</strong></h2>

<h3 id="fastlane"><strong><a href="https://github.com/fastlane/fastlane">Fastlane</a></strong></h3>

<p>iOS 中最好用的自动化工具。提供了获取证书、运行自动化测试、上传至 TestFlight 和 AppStore 等功能。配置简单，社区强大，具体的功能可以到这个网站查看：<a href="https://fastlane.tools/">fastlane.tools</a>。</p>

<h2 id="functional-reactive-programming"><strong>Functional Reactive Programming</strong></h2>

<p>使用响应式编程框架统一对委托、回调 blocks 、通知 、控件的事件 、KVO 等异步事件的逻辑处理。可以显著的降低代码复杂度，更有效的传达代码意图。任何一个优秀的 iOS 程序员都不会拒绝响应式编程，唯一的缺点可能就是对智商有要求了。</p>

<p>RAC 和 Rx 都有着广泛的使用用户。个人拙见两个库的选择全靠个人偏好，在编程范式上没有区别。</p>

<h3 id="reactivecocoa"><strong><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a></strong></h3>

<p>OC 时代最流行的响应式框架。由 github 团队开源。如果项目是从 OC 迁移到 swift 的，继续使用 RAC 是一个非常自然的选择。因此 RAC 有着广泛的社区支持。从 5.0 开始主要框架逻辑已经全由 swift 实现。与 RxSwift 编程模型最大的区别是冷热信号由两种类型表示。</p>

<h3 id="rxswift"><strong><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a></strong></h3>

<p>函数响应式编程 (Funtional Reactive Programming) 系列 ReactiveX 的 Swift 版本开源框架。推出时间较晚，其思路与 ReactiveCocoa 相近，它们的共同祖先是微软的 ReactiveExtensions，本质核心就是面向数据流编程。</p>

<h2 id="代码分析"><strong>代码分析</strong></h2>

<p>###<a href="https://github.com/realm/SwiftLint">SwiftLint</a> Realm 出品的 Swift 代码规范检测工具。深度嵌入 Clang 和 SourceKit，可以监测整个项目的代码风格。如果有不符合规范之处，SwiftLint会报出相应警告⚠️。当然为了方便和特殊情况，也可在相应代码处手动关闭警告，或是在整个项目中关闭警告，十分灵活。</p>

<p>代码规范请参考：<a href="https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md">Swift Style Guide</a></p>

<h3 id="logan"><a href="https://github.com/Meituan-Dianping/Logan">Logan</a></h3>

<p>对于一个 App 来讲，日志的收集、上报、查询是非常重要的。而目前在各个公司中，对日志的处理大多并没有形成一套完整的体系，都是针对不同的日志类型，如crash、性能、打点等等进行单独的处理。近日，美团点评开源了移动端基础日志库 Logan ，Logan 是一个功能完善、无侵入的日志框架，解决了很多移动端日志方面的痛点，并且拥有较好的性能，可以很方便的接入。</p>

<h2 id="工具">工具</h2>

<h3 id="merchantkit"><a href="https://github.com/benjaminmayo/merchantkit">MerchantKit</a></h3>

<p>现代 iOS 内购管理框架，极大地简化了独立开发者的工作，可以追踪被购买的项目、检索购买、管理订阅到期日期、恢复购买、验证购买等等。MerchantKit 为具有一系列内购项目的 app 而设计，是为应用增加 pro 版本的绝佳方式，不论是一次性购买还是采取订阅方式。</p>

<h1 id="thanks"><strong>Thanks</strong></h1>

<p><a href="https://github.com/vsouza/awesome-ios">awesome-ios</a></p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/hydeout/2020/01/13/promisekit-startup.html">
        PromiseKit 入门指南
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">13 Jan 2020</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/hydeout/category/iOS">
          iOS
        </a>
      
    
  </span>
</div>


    
      <h1 id="开始使用">开始使用</h1>

<h2 id="then-与-done">then 与 done</h2>

<p>以下是一个经典的 promise 链:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">login</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">creds</span> <span class="k">in</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">image</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">imageView</span> <span class="o">=</span> <span class="n">image</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果这段代码使用闭包回调的话，会长成这个样子:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">login</span> <span class="p">{</span> <span class="n">creds</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">creds</span> <span class="o">=</span> <span class="n">creds</span> <span class="p">{</span>
        <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span> <span class="n">image</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="n">image</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">imageView</span> <span class="o">=</span> <span class="n">image</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">then</code> 函数是另外一个构建闭包回调的方法，但这种做法要比之前的 <code class="highlighter-rouge">completion handler</code> 方法好很多。它主要帮助我们更好的阅读这段代码。上面的 promise 链是非常容易阅读和理解的: 一个异步操作引出另一个异步操作。这段伪代码与程序代码非常接近，我们很容易理解这段 Swift 代码的当前含义。</p>

<p><code class="highlighter-rouge">done</code> 函数和 <code class="highlighter-rouge">then</code> 含义是一样的，但是 <code class="highlighter-rouge">done</code> 没有返回一个承诺链。它常常被用于“成功链”的结尾。以上，我们可以看到在 <code class="highlighter-rouge">done</code> 函数中接受一个最终的 image 对象，并且被用来初始化我们的 UI 操作。</p>

<p>让我们来对比以下两种方法:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">login</span><span class="p">()</span><span class="o">-&gt;</span><span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">Creds</span><span class="o">&gt;</span>

<span class="c1">//对比：</span>

<span class="kd">func</span> <span class="nf">login</span><span class="p">(</span><span class="nv">completion</span><span class="p">:(</span><span class="kt">Creds</span><span class="p">?,</span><span class="kt">Error</span><span class="p">?)</span><span class="o">-&gt;</span><span class="kt">Void</span><span class="p">)</span> <span class="c1">//额。这边有两个可选值</span>
</code></pre></div></div>

<p>这个两者区别在于使用了前者使用了<code class="highlighter-rouge">Promise</code>包装了Creds对象，你的方法返回了<code class="highlighter-rouge">Promise</code>对象而不是一个回调函数。每一个在响应链中的回调函数都会返回一个<code class="highlighter-rouge">Promise</code>对象。<code class="highlighter-rouge">Promise</code>对象中定义<code class="highlighter-rouge">then</code>方法，该方法在继续链之前等待前一个<code class="highlighter-rouge">Promise</code>任务的完成。<code class="highlighter-rouge">Promise</code>任务链会以程序化的方式解决问题，一次完成一个任务。</p>

<p>一个 <code class="highlighter-rouge">Promise</code> 代表了一个未来的异步任务。它用泛型语法包装了一个对象的真实类型。比如，在以上的例子中， <code class="highlighter-rouge">login</code> 是一个方法返回了一个 <code class="highlighter-rouge">Promise</code> 对象，但是他的真实类型是一个 <code class="highlighter-rouge">Creds</code> 的实例。</p>

<blockquote>
  <p><em>注意</em>：<code class="highlighter-rouge">done</code>是在PromiseKit 5中新特性。我们之前定义了<code class="highlighter-rouge">then</code>的变体，没有要求你返回一个<code class="highlighter-rouge">Promise</code>对象。不幸的是，这种惯例经常混淆Swift使用者，并且导致了奇怪且难以调试的错误消息。它使用使用PromiseKit是一件痛苦的事情。<code class="highlighter-rouge">done</code>的引入让你在使用了promise链的时候，编译器可以很便捷的给类型提示信息。</p>
</blockquote>

<p>你可能会注意到与回调函数模式不同的是，promise 链模式似乎忽略了错误。不是这种情况！事实上，与此相反: promise 链模式的错误处理更加容易处理，更加难以忽略。</p>

<h2 id="catch">catch</h2>

<p>使用 promise 链模式，错误会沿着链逐级传递，确保你的应用程序代码正常健壮，代码逻辑清晰明确:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstly</span><span class="p">{</span>
        <span class="nf">login</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span><span class="p">{</span> <span class="n">creds</span> <span class="k">in</span>
        <span class="nf">featch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span><span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span><span class="p">{</span> <span class="n">image</span> <span class="k">in</span>
        <span class="k">self</span><span class="o">.</span><span class="n">imageView</span> <span class="o">=</span> <span class="n">image</span>  
<span class="p">}</span><span class="o">.</span><span class="k">catch</span><span class="p">{</span>
        <span class="c1">//整个promise链的任何错误都归于此</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>如果你忘了”抓住”链条，Swift 会发出警告。我们稍后会详细讨论这个问题。</p>
</blockquote>

<p>每个 promise 链都表示单个异步任务。如果任务执行失败，其 promise 将被 rejected。包含被拒绝 promise 链将跳出所有后续的 <code class="highlighter-rouge">then</code> 任务。将执行下一个 <code class="highlighter-rouge">catch</code> 任务。（严格地说，所有后续 <code class="highlighter-rouge">catch</code> 回调都被执行。)</p>

<p>为了好玩，让我们将此模式与闭包模式（ <code class="highlighter-rouge">comletion handler</code> 模式）进行比较:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span>

<span class="n">login</span> <span class="p">{</span> <span class="n">creds</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">creds</span> <span class="o">=</span> <span class="n">creds</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span> <span class="p">}</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span> <span class="n">image</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="n">image</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这段代码使用 <code class="highlighter-rouge">guard</code> 和一个统一的错误处理，但是 promise 链的可读性说明了一切。</p>

<h2 id="ensure">ensure</h2>

<p>我们已经学会了异步组合。接下来让我们扩展更多的函数操作:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="k">return</span> <span class="nf">login</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">imageView</span> <span class="o">=</span> <span class="nv">$0</span>
<span class="p">}</span><span class="o">.</span><span class="n">ensure</span> <span class="p">{</span>
    <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不论你的 promise 链输出是什么，成功或者失败，你的 <code class="highlighter-rouge">ensure</code> 回调永远会被执行的。</p>

<p>我们将此模式与它的闭包回调模式进行对比：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">true</span>

<span class="kd">func</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="c1">//…</span>
<span class="p">}</span>

<span class="n">login</span> <span class="p">{</span> <span class="n">creds</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">creds</span> <span class="o">=</span> <span class="n">creds</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span> <span class="p">}</span>
    <span class="nf">fetch</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">creds</span><span class="o">.</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span> <span class="n">image</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="n">image</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对于有些人来说，修改这段代码或者取消设置活动指示器，非常容易导致出现 bug。使用 promise 链模式，这类错误几乎不可能会发生：在不使用改模式的情况下，Swift 编译器不会给你编译提示。通过使用这种模式，您几乎不需要查看提交的代码。</p>

<blockquote>
  <p>提示：PromiseKit 为了这个函数可能在名字 <code class="highlighter-rouge">always</code> 和 <code class="highlighter-rouge">ensure</code> 之间反复无常地切换。 为此表示歉意。 我们做的很糟糕。</p>
</blockquote>

<p>你还可以使用 <code class="highlighter-rouge">finally</code> 作为一种 <code class="highlighter-rouge">ensure</code> , 用于终止 promise 链并且没有返回值:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">spinner</span><span class="p">(</span><span class="nv">visible</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>

<span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span><span class="o">.</span><span class="n">finally</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">spinner</span><span class="p">(</span><span class="nv">visible</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="when">when</h2>

<p>使用闭包回调模式，对对个异步操作做出反应不是写的很慢就是很难写出优雅的代码。</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">operation1</span> <span class="p">{</span> <span class="n">result1</span> <span class="k">in</span>
    <span class="n">operation2</span> <span class="p">{</span> <span class="n">result2</span> <span class="k">in</span>
        <span class="nf">finish</span><span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种编码方式使得代码目的不够清晰:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">result1</span><span class="p">:</span> <span class="err">…</span><span class="o">!</span>
<span class="k">var</span> <span class="nv">result2</span><span class="p">:</span> <span class="err">…</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">group</span> <span class="o">=</span> <span class="kt">DispatchGroup</span><span class="p">()</span>
<span class="n">group</span><span class="o">.</span><span class="nf">enter</span><span class="p">()</span>
<span class="n">operation1</span> <span class="p">{</span>
    <span class="n">result1</span> <span class="o">=</span> <span class="nv">$0</span>
    <span class="n">group</span><span class="o">.</span><span class="nf">leave</span><span class="p">()</span>
<span class="p">}</span>
<span class="n">operation2</span> <span class="p">{</span>
    <span class="n">result2</span> <span class="o">=</span> <span class="nv">$0</span>
    <span class="n">group</span><span class="o">.</span><span class="nf">leave</span><span class="p">()</span>
<span class="p">}</span>
<span class="n">group</span><span class="o">.</span><span class="nf">notify</span><span class="p">(</span><span class="nv">queue</span><span class="p">:</span> <span class="o">.</span><span class="n">main</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">finish</span><span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用 Promise 模式会变得更简单:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">when</span><span class="p">(</span><span class="nv">fulfilled</span><span class="p">:</span> <span class="nf">operation1</span><span class="p">(),</span> <span class="nf">operation2</span><span class="p">())</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span> <span class="k">in</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">when</code> 接受 <code class="highlighter-rouge">Promise</code> 对象，等待他们解决，并返回包含结果的 <code class="highlighter-rouge">Promise</code> 对象。</p>

<p>与任何 <code class="highlighter-rouge">Promise</code> 链一样，如果任何 <code class="highlighter-rouge">Promise</code> 任务失败了，该链将调用下一个 <code class="highlighter-rouge">catch</code> 任务回调。</p>

<h1 id="promisekit-扩展工具包">PromiseKit 扩展工具包</h1>

<p>当我们制作 <code class="highlighter-rouge">PromiseKit</code> 工具包时，我们知道我们只想使用 <code class="highlighter-rouge">Promise</code> 来实现异步行为。因此，只要有可能，我们就会为苹果的API提供扩展，根据 <code class="highlighter-rouge">Promise</code> 重新构建 API。例如:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="kt">CLLocationManager</span><span class="o">.</span><span class="nf">promise</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">location</span> <span class="k">in</span>
    <span class="kt">CLGeocoder</span><span class="o">.</span><span class="nf">reverseGeocode</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">placemarks</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">placemark</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">placemarks</span><span class="o">.</span><span class="n">first</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>要使用这些扩展，你需要安装如下 pod 库:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pod</span> <span class="s">"PromiseKit"</span>
<span class="n">pod</span> <span class="s">"PromiseKit/CoreLocation"</span>
<span class="n">pod</span> <span class="s">"PromiseKit/MapKit"</span>
</code></pre></div></div>

<p>所有这些扩展都可以在 PromiseKit 组织上找到。去那里看看有什么可用的，并阅读源代码和文档。每个文件和函数已被大量记录在案。</p>

<blockquote>
  <p>我们还为 <code class="highlighter-rouge">Alamofire</code> 等公共库提供扩展。</p>
</blockquote>

<h2 id="创建-promises">创建 Promises</h2>

<p>标准扩展会让您走很长的路，但有时您仍然需要创建自己的<code class="highlighter-rouge">Promise</code>链。如果你使用额第三方库没有提供<code class="highlighter-rouge">Promise</code>扩展，或者你已经写好了自己的异步程序。不管怎样，添加<code class="highlighter-rouge">Promise</code>都很容易。如果你看一下标准扩展库，您将看到它使用下面描述的相同方法。</p>

<p>假设我们有以下方法：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="p">(</span><span class="kt">String</span><span class="p">?,</span> <span class="kt">Error</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span>
</code></pre></div></div>

<p>我们怎么才能转换成一个 <code class="highlighter-rouge">Promise</code> 呢，这很简单：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Promise</span> <span class="p">{</span> <span class="nf">fetch</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">resolve</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>您可能会发现扩展版本更具可读性：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Promise</span> <span class="p">{</span> <span class="n">seal</span> <span class="k">in</span>
        <span class="n">fetch</span> <span class="p">{</span> <span class="n">result</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
            <span class="n">seal</span><span class="o">.</span><span class="nf">resolve</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个<code class="highlighter-rouge">seal</code>对象是“Promise”初始化器提供的，用于定义很多方法来处理多重闭包回调的问题的。它甚至可以用来处理各种罕见的情况，从而使您很容易对现有代码库的添加<code class="highlighter-rouge">Promise</code>扩展。</p>

<blockquote>
  <p>注意：我们试图让它只做Promise(fetch)，但是我们不能让这个更简单的模式在不需要额外消除Swift编译器歧义的情况下普遍工作。对不起，我们尝试过但没有成功。</p>
</blockquote>

<blockquote>
  <p>注意：在PromiseKit 4中，这个初始化器为闭包提供了两个参数: <code class="highlighter-rouge">fulfill</code> 和 <code class="highlighter-rouge">reject</code>。PromiseKit 5和6为您提供了一个对象，该对象具有 <code class="highlighter-rouge">fulfill</code> 和 <code class="highlighter-rouge">reject</code> 方法，但也有方法解析的许多变体。通常，您只需传递要解析的回调函数参数给 <code class="highlighter-rouge">resolve</code>，并让Swift找出应用于特定情况的变体(如上面的示例所示)。</p>
</blockquote>

<blockquote>
  <p>注意： <code class="highlighter-rouge">Guarantee</code> (下面)是一个稍微不同的初始化器(因为它们不能出错)，所以初始化器闭包的参数只是一个闭包。不是 <code class="highlighter-rouge">Resolver</code> 对象。因此，应该 <code class="highlighter-rouge">seal(value)</code> 而不是 <code class="highlighter-rouge">seal.fulfill(value)</code>。这是因为没有什么变化在 <code class="highlighter-rouge">Guarantee</code> 中是未知的，它们只能 <code class="highlighter-rouge">fulfill</code>。</p>
</blockquote>

<h2 id="guarantee">Guarantee<T></T></h2>

<p>从 PromiseKit 5 开始，我们就提供了 <code class="highlighter-rouge">Guarantee</code> 作为 <code class="highlighter-rouge">Promise</code> 的补充类。我们这样做是为了补充 Swift 强大的错误处理系统。</p>

<p><code class="highlighter-rouge">Guarantee</code> 永远不会失败，所以它们不能被 <code class="highlighter-rouge">reject</code> 。一个很好的例子是 <code class="highlighter-rouge">after</code> :</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">after</span><span class="p">(</span><span class="nv">seconds</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span>
    <span class="c1">// 没有办法添加“catch”，因为after不能失败。</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果你不终止一个常规的<code class="highlighter-rouge">Promise</code>链，Swift会对你做出编译警告。（不是一个<code class="highlighter-rouge">Guarantee</code>链）。您应该通过提供一个<code class="highlighter-rouge">catch</code>或一个<code class="highlighter-rouge">return</code>来消除这个警告。(在后一种情况下，你可以获得得到的promise链。)</p>

<p>尽可能使用<code class="highlighter-rouge">Guarantee</code>，以便代码在需要的地方有错误处理，在不需要的地方没有错误处理。</p>

<p>一般来说，您应该能够交替使用<code class="highlighter-rouge">Guarantee</code>和<code class="highlighter-rouge">Promise</code>，我们已经尽了最大的努力来确保这一点，所以如果您发现任何问题请及时给我们提issue。</p>

<p>如果您正在创建自己的<code class="highlighter-rouge">Guarantee</code>，那么语法将比<code class="highlighter-rouge">Promise</code>更简单</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Guarantee</span> <span class="p">{</span> <span class="n">seal</span> <span class="k">in</span>
        <span class="n">fetch</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
            <span class="nf">seal</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以归结为：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">fetch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Guarantee</span><span class="p">(</span><span class="nv">resolver</span><span class="p">:</span> <span class="n">fetch</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="map-compactmap-等等">map, compactMap 等等</h2>

<p><code class="highlighter-rouge">then</code>向您提供前一个承诺的结果，并要求您返回另一个承诺。<code class="highlighter-rouge">map</code>提供了前面承诺的结果，并要求您返回一个引用类型或值类型。<code class="highlighter-rouge">compactMap</code>提供了前面承诺的结果，并要求您返回一个可选的。如果返回nil，则该链将会返回<code class="highlighter-rouge">PMKError.compactMap</code>错误。</p>

<blockquote>
  <p>理由：在PromiseKit 4之前， <code class="highlighter-rouge">then</code> 会处理所有这些情况，这是非常糟糕的设计。我们希望这些痛苦会随着新版本的 Swift 而逐步消失。然而，很明显，各种各样的痛点都会存在。事实上，作为库的作者，我们应该在API的命名级别消除歧义。因此，我们将当时的三种主要类型分为 <code class="highlighter-rouge">then</code>、 <code class="highlighter-rouge">map</code>和 <code class="highlighter-rouge">done</code>。在使用了这些新函数之后，我们意识到这在实践中要好得多，所以我们也添加了 <code class="highlighter-rouge">compactMap</code>(以 <code class="highlighter-rouge">Optional.compactMap</code>为模型)。</p>
</blockquote>

<p><code class="highlighter-rouge">compactMap</code>有助于快速组合承诺链。例如:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">firstly</span> <span class="p">{</span>
    <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="o">.</span><span class="n">promise</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">rq</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">compactMap</span> <span class="p">{</span>
    <span class="k">try</span> <span class="kt">JSONSerialization</span><span class="o">.</span><span class="nf">jsonObject</span><span class="p">(</span><span class="nv">$0</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">as?</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">arrayOfStrings</span> <span class="k">in</span>
    <span class="c1">//…</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">error</span> <span class="k">in</span>
    <span class="c1">// Foundation.JSONError if JSON was badly formed</span>
    <span class="c1">// PMKError.compactMap if JSON was of different type</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>提示:我们还为序列提供了您期望的大多数函数方法，例如 <code class="highlighter-rouge">map</code>、 <code class="highlighter-rouge">thenMap</code>、 <code class="highlighter-rouge">compactMapValues</code>、 <code class="highlighter-rouge">firstValue</code>等。</p>
</blockquote>

<h2 id="get">get</h2>

<p>我们提供了 <code class="highlighter-rouge">get</code> 函数，类似 <code class="highlighter-rouge">done</code>, 主要用于获取返回值。</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="k">get</span> <span class="p">{</span> <span class="n">foo</span> <span class="k">in</span>
    <span class="c1">//…</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span> <span class="n">foo</span> <span class="k">in</span>
    <span class="c1">// same foo!</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="tap">tap</h2>

<p>我们提供 <code class="highlighter-rouge">tap</code> 用于 debug。它与 <code class="highlighter-rouge">get</code> 类似，但是提供了 <code class="highlighter-rouge">Promise</code> 的 <code class="highlighter-rouge">Result&lt;T&gt;</code>，因此您可以检查此时promise链中的值，而不会产生任何副作用:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">tap</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">done</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="补充">补充</h1>

<h2 id="firstly">firstly</h2>

<p>我们在这一页上已经使用 <code class="highlighter-rouge">firstly</code> 函数好几次了，但是它到底是什么呢?事实上，它只是个语法糖。您并不真正需要它，但它有助于使您的 promise 链更具可读性。</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstly</span> <span class="p">{</span>
    <span class="nf">login</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">creds</span> <span class="k">in</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以这样做:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">login</span><span class="p">()</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">creds</span> <span class="k">in</span> 
		<span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里有一个关键的理解:login()函数返回一个<code class="highlighter-rouge">Promise</code>，所有<code class="highlighter-rouge">Promise</code>都有一个<code class="highlighter-rouge">then</code>函数。<code class="highlighter-rouge">firstly</code>返回一个<code class="highlighter-rouge">Promise</code>，然后<code class="highlighter-rouge">then</code>也返回一个<code class="highlighter-rouge">Promise</code>！但是不要太担心这些细节。从学习这种模式开始。然后，当您准备好前进时，继续学习底层架构。</p>

<h2 id="when的变体">when的变体</h2>

<p><code class="highlighter-rouge">when</code>是Promisekit中很有用的几个函数之一，因此我们提供了几个变体。</p>

<ul>
  <li>默认的<code class="highlighter-rouge">when</code>是<code class="highlighter-rouge">when(fulfilled:)</code>，您通常应该使用它。这种变体等待他所有承诺组件完成，但如果有任何一个承诺失败了，<code class="highlighter-rouge">when</code>也失败，因此promise链将会被“拒绝”继续执行。需要注意的是，所有的promise都在<code class="highlighter-rouge">when</code>中继续执行。promise无法控制它们所代表的任务。promise只是任务的分装。</li>
  <li><code class="highlighter-rouge">when(resolved:)</code> 将会继续等待，即使它的一个或多个承诺组件失败了。when的这种变体产生的值是一个Result<T>的数组。因此，该变体要求其所有组件承诺具有相同的泛型类型。有关此限制，请参阅我们的高级模式指南。</T></li>
  <li><code class="highlighter-rouge">race</code>变体允许您竞逐多个承诺。无论谁先完成都是结果。有关典型用法，请参阅高级模式指南。</li>
</ul>

<h1 id="swift-闭包的用法">Swift 闭包的用法</h1>

<p>Swift自动推断单行闭包的返回和返回类型。以下两种形式是相同的:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span>
    <span class="nf">bar</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// is the same as:</span>

<span class="n">foo</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="n">baz</span> <span class="o">-&gt;</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="k">in</span>
    <span class="k">return</span> <span class="nf">bar</span><span class="p">(</span><span class="n">baz</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们的文档经常为了清晰而省略返回值。</p>

<p>然而，这种简写既是福也是祸。您可能会发现，Swift编译器经常无法正确推断返回类型。如果您需要进一步的帮助，请参阅我们的故障排除指南。</p>

<blockquote>
  <p>PromiseKit 5 中添加 <code class="highlighter-rouge">done</code>函数，我们成功地避免了在使用 PromiseKit 和 Swift 过程中的许多常见痛点。</p>
</blockquote>

<h1 id="延伸阅读">延伸阅读</h1>

<p>以上信息是在使用PromiseKit中的90%了。我们强烈建议阅读<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmxcl.dev%2FPromiseKit%2Freference%2Fv6%2FClasses%2FPromise.html">API指南</a>。有许多简短的函数可能对您有帮助，上面所有的内容在源代码的中的概述都更加全面。</p>

<p>在Xcode中编码时，单击PromiseKit函数来访问该文档。</p>

<p>这里是一些最近的文章，文档基于PromiseKit 5+:</p>

<ul>
  <li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fagostini.tech%2F2018%2F10%2F08%2Fusing-promisekit">Using Promises - Agostini.tech</a></li>
</ul>

<p>小心一些网上的参考文章，他们中的许多人提到PromiseKit版本都小于5，这里面有些API是不相同的(抱歉，但Swift多年来已经改变了很多，因此我们也不得不这么做)。</p>

    

    
      
      
      

      
    
  </article>
  

  
<div class="pagination">
  <a class="pagination-item older"
     href="/hydeout/page2">
    Older
  </a>
</div>


</div>
    </main>

    <!-- Optional footer content -->

  </body>
</html>
