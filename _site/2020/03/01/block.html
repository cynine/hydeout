<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Blocks &middot; Cynine
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/hydeout/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/hydeout/favicon.png" />
<link rel="shortcut icon" href="/hydeout/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/hydeout/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="post">

    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/hydeout/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Cynine
      </a>
    </div>
    <p class="lead">Everything I do now, is in pursuit of more perfect.</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/hydeout/">Home</a>
  
  

  

  


  
    
  

  
    
  

  
    
  

  
    
  

  
    
      <a class="page-link "
          href="/hydeout/about">About</a>
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  

  
    
  


  


  
    
  

  
    
      <a class="category-link "
          href="/hydeout/category/Developer">开发笔记</a>
    
  

  
    
      <a class="category-link "
          href="/hydeout/category/Flutter">Flutter</a>
    
  

  
    
      <a class="category-link "
          href="/hydeout/category/Python">Python</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/hydeout/category/iOS">iOS</a>
    
  

  
    
  

  

  
    
  

  
    
  

  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  
    <a id="github-link"
       class="icon" title="Github Project" aria-label="Github Project"
       href="https://github.com/Cynine/hydeout">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 28" height="24" width="28"><path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</svg>

    </a>
    <a id="github-download-link"
       class="icon" title="Download" aria-label="Download"
       href="https://github.com/Cynine/hydeout/archive/v4.0.2.zip">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/hydeout/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/hydeout/tags">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/hydeout/search">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>

  <p>
  &copy; 2020.
  <a href="/hydeout/LICENSE.md">MIT License.</a>
</p>

</div>

    <main class="container">
      <header>
  <h1 class="post-title">Blocks</h1>
</header>
<div class="content">
  <div class="post-meta">
  <span class="post-date">01 Mar 2020</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/hydeout/category/iOS">
          iOS
        </a>
      
    
  </span>
</div>


  <div class="post-body">
    <h2 id="blocks-知识点">Blocks 知识点</h2>
<p><img src="assets/15835447426404.jpg" alt="img" /></p>

<h2 id="前言">前言</h2>
<ul>
  <li>block的原理是怎样的？本质是什么？</li>
  <li>__block的作用是什么？有什么使用注意点？</li>
  <li>block的属性修饰词为什么是copy？使用block有哪些使用注意？</li>
  <li>block在修改NSMutableArray，需不需要添加__block？</li>
</ul>

<h2 id="1-blocks-概要">1. Blocks 概要</h2>
<h3 id="11-什么是-blocks">1.1 什么是 Blocks</h3>

<p>Blocks 是 C 语言的扩充功能，即：<strong>带有自动变量（局部变量）的匿名函数</strong>。</p>
<ul>
  <li>“带有自动变量”：为保证 Blocks 能正常访问外部的变量，Blocks 有一个自动捕获变量的机制。Blocks 能自动捕获（保存）在其内部使用到的外部自动变量（局部变量）的<strong>瞬间值</strong>。</li>
  <li>匿名函数:不带有名称的函数。</li>
</ul>

<p>其他语言中 Block 的名称</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">程序语言</th>
      <th style="text-align: center">Block 的名称</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">C + Blocks</td>
      <td style="text-align: center">Block</td>
    </tr>
    <tr>
      <td style="text-align: center">Smalltalk</td>
      <td style="text-align: center">Block</td>
    </tr>
    <tr>
      <td style="text-align: center">Ruby</td>
      <td style="text-align: center">Block</td>
    </tr>
    <tr>
      <td style="text-align: center">LISP</td>
      <td style="text-align: center">Block</td>
    </tr>
    <tr>
      <td style="text-align: center">Python</td>
      <td style="text-align: center">Lambda</td>
    </tr>
    <tr>
      <td style="text-align: center">C++ 11</td>
      <td style="text-align: center">Lambda</td>
    </tr>
    <tr>
      <td style="text-align: center">JavaScript</td>
      <td style="text-align: center">Anonymous fucntion</td>
    </tr>
  </tbody>
</table>

<h2 id="2-block-模式">2. Block 模式</h2>
<h3 id="21-block-语法">2.1 Block 语法</h3>
<p>完整形式的 Block 语法与一般的 C 语言函数定义相比，仅有两点不同：</p>
<ol>
  <li>没有函数名: 因为 Block 是匿名函数。</li>
  <li>带有“\^” （插入记号，caret）记号: 因为 OS X、iOS 应用程序的源代码中将大量使用 Block，所以插入该记好便于查找。</li>
</ol>

<p>Block 声明语法:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^ 返回值类型 参数列表 表达式

e.g:
^int (int count) { return count + 1; };
</code></pre></div></div>
<p>Block 语法的简化：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 省略返回值类型（表达式含有 return 语句时，其返回值类型必定与 return 返回值的类型一致）

^ 参数列表 表达式

e.g:
^(int count) { return count + 1; };

2. 省略返回值类型和参数列表

^表达式

e.g:
^{ return count + 1 };
</code></pre></div></div>
<h3 id="22-block-类型变量">2.2 Block 类型变量</h3>

<p>Block 语法但从记述方式来看，除了没有名称和带有“\^”以外，其他的都与 C 语言函数定义相同。在定义 C 语言函数时，可以将定义函数的地址赋值给函数指针变量中。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">funcptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">;</span>
</code></pre></div></div>

<p>在 Block 的语法下，可将 Block 语法赋值给声明为 Block 类型的变量中。即源代码中一旦使用 Block 语法就相当于生成了可赋值给 Block 类型变量的“值”。在 Blocks 中，“Block” 既指源代码中的 Block 语法，也指由 Block 语法所生成的值。
声明 Block 类型变量：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>
<p>与前面对比使用函数指针的源代码对比，声明 Block 类型变量仅仅是将声明函数指针类型变量的 “*” 变成了 “\^”。该 Block 类型变量的与一般的 C 语言变量完成相同，可做为以下用途使用:</p>
<ul>
  <li>自动变量</li>
  <li>函数参数</li>
  <li>静态变量</li>
  <li>静态全局变量</li>
  <li>全局变量
使用 Block 语法将 Block 赋值为 Block 类型变量:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div>
<ul>
  <li>由 Block 类型变量向 Block 类型变量赋值：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk1</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">blk</span><span class="p">;</span>

<span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk2</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">blk2</span> <span class="o">=</span> <span class="n">blk1</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>将 Block 类型变量作为函数参数使用：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>
<ul>
  <li>将 Block 作为函数的返回值返回：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">func</span><span class="p">())(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">){</span><span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;};</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>使用 <code class="highlighter-rouge">typedef</code> 简化上述操作：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

<span class="cm">/* 原来的记述方式 
void func(int (^blk)(int))
*/</span>

<span class="err">简化为：</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">blk_t</span> <span class="n">blk</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/* 原来的记述方式
int (^func()(int))
*/</span>

<span class="err">简化为：</span>
<span class="n">blk_t</span> <span class="n">func</span><span class="p">()</span>
</code></pre></div></div>
<p>将赋值给 Block 类型变量中的 Block 方法的调用与使用函数指针类型变量调用函数的方法几乎完全相同：</p>
<ul>
  <li>调用函数指针类型变量:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">funcptr</span><span class="p">)(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>调用 Block 类型变量:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">blk</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>
<p>Block 类型变量调用 Block 与 C 语言通常的函数调用没有区别。在函数参数重使用 Block 类型变量并在函数中执行 Block 的例子:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="n">blk_t</span> <span class="n">blk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">blk</span><span class="p">(</span><span class="n">rete</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在 Objective-C 中方法使用:</p>

<div class="language-objectivec highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">methodUsingBlock</span><span class="p">:(</span><span class="n">blk_t</span><span class="p">)</span><span class="nv">blk</span> <span class="nf">rete</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="nv">rete</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">blk</span><span class="p">(</span><span class="n">rete</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Block 类型变量可完全像通常的 C 语言变量一样使用，因此也可以使用之乡 Block 类型变量的指针，即 Block 的指针类型变量:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blk_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

<span class="n">blk_t</span> <span class="n">blk</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">){</span><span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>

<span class="n">blk_t</span> <span class="o">*</span><span class="n">blkprt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">blk</span><span class="p">;</span>

<span class="p">(</span><span class="o">*</span><span class="n">blkptr</span><span class="p">)(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>
<h3 id="23-截获自动变量值">2.3 截获自动变量值</h3>
<p>“带有自动变量值”在 Blocks 中表现为“截获自动变量值”。截获自动变量值的实例如下:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">dmy</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="s">"val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);};</span>
    
    <span class="n">val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="s">"Thes values were changed. val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    
    <span class="n">bll</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// val = 10</span>
</code></pre></div></div>
<p>在该代码中， Block 语法的表达式使用的是它之前声明的自动变量 fmt 和 val。Blocks 中，Block 表达式截获所使用的自动变量值，即保存该自动变量的<strong>瞬间值</strong>。在执行 Block 语法后，即使改写 Block 中使用的自动变量的值也不会影响 Block 执行时变量的值。该 Block 语法执行时，字符串指针 “val=%d\n”被赋值到自动变量 fmt 中，int 值 10 被赋值到自动变量 val 中，因此这些值被保存（即被截获），从而在执行块时使用。<strong>这就是自动变量值的捕获</strong>。</p>

<h3 id="24-__block-说明符">2.4 __block 说明符</h3>
<p>若想在 Block 语法的表达式中将赋给 Block 语法外声明的自动变量，需要在该自动变量上附加 <code class="highlighter-rouge">__block</code> 说明符。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>

<span class="n">blk</span><span class="p">();</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

<span class="c1">// val = 1</span>
</code></pre></div></div>
<p>使用附有 <code class="highlighter-rouge">__block</code> 说明符的自动变量可在 Block 中赋值，<strong>该变量称为 __block 变量</strong>。</p>
<h2 id="3-blocks-的实现">3 Blocks 的实现</h2>
<h3 id="31-block-的实质">3.1 Block 的实质</h3>
<p>通过 clang（LLVM 编译器）将 Objective-C 源代码转换为 C++ 的源代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -rewrite-objc 源代码文件名
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span> <span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="p">};</span>

    <span class="n">blk</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>通过 clang 将上述代码转换成 C++ 代码得：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__block_impl</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> 
    <span class="mi">0</span><span class="p">,</span> 
    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">));</span>

    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对比最初的源代码中的 Block 语法：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">)};</span>
</code></pre></div></div>

<p>转换为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>如转换的源代码所示，通过 Blocks 使用的匿名函数实际上被作为简单的 C 语言函数来处理。另外，根据 Block 语法所属的函数名（此处为main）和该 Block 语法在该函数出现的顺序值（此处为0）来经 clang 变换的函数命名。</p>

<p><code class="highlighter-rouge">__cself</code> 相当于 C++ 实例方法中指向实例自身的变量 <code class="highlighter-rouge">this</code>，或是 Objective-C 实例方法中指向对象自身的变量 <code class="highlighter-rouge">self</code>, 即参数 <code class="highlighter-rouge">__cself</code> 为指向 Block 值的变量。<code class="highlighter-rouge">__cself</code> 声明如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span>
</code></pre></div></div>

<p>与 C++ 的 this 和 Objective-C 的 self 相同， 参数 __cself 是 __main_block_impl_0 结构题的指针。该结构体声明如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span> <span class="c1">// 今后版本升级所需的区域以及函数指针</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span> <span class="c1">// 其结构为今后版本升级所需要区域和 Block 的大小</span>
<span class="p">};</span>	
</code></pre></div></div>

<p><strong>__block_impl</strong> 结构体的声明：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__block_impl</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span> 
  <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>__main_block_desc_0</strong> 结构体声明：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>再看 <strong>__main_block_impl_0</strong> 结构的构造函数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span> 
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该构造函数的调用：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> 
  <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">(</span>
     <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">));</span>
</code></pre></div></div>

<p>去掉强制转化部分，可得：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__mian_block_impl_0</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">__main_block_impl_0</span><span class="p">(</span>
     <span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">blk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
</code></pre></div></div>

<p>该代码将 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体类型的自动变量，即栈上生成的 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例的指针，赋值给 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体指针类型的变量 <code class="highlighter-rouge">blk</code>。这部分最初的源代码为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="o">^</span> <span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Block</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="p">};</span>	
</code></pre></div></div>

<p>将 Block 语法生成的 Block 赋值给 Block 类型的变量 blk。等同于将 <code class="highlighter-rouge">__main_block_impl_0</code>  结构体实例的指针赋值给 <code class="highlighter-rouge">blk</code>。该源代码中的 Block 就是 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体类型的自动变量，即栈上生成的 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例。</p>

<p>由 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体源代码可得，该结构体的构造函数的构造参数为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__main_block_impl_0</span><span class="p">(</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">);</span>
</code></pre></div></div>

<p>第一个参数是由 Block 语法转换的 C 语言函数指针。第二个参数是作为静态全局变量初始化的 <code class="highlighter-rouge">__main_block_desc_0</code> 结构体实例指针。以下是 <code class="highlighter-rouge">__main_block_desc_0</code>  结构体实例的初始化部分代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span>  <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> 
    <span class="mi">0</span><span class="p">,</span> 
    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由此可知，该源代码使用 Block， 即 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体的实例的大小，进行初始化。</p>

<p>栈上 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例（即 Block）参数的初始化过程：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 展开 __main_block_impl_0 结构体的 __block_impl 结构体</span>
<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span> 
  <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span> 
<span class="p">};</span>	
</code></pre></div></div>

<p>该构造体根据构造函数会像下面这样进行初始化：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span> 
<span class="n">Flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">__main_block_func_0</span><span class="p">;</span>
<span class="n">Desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">;</span>
</code></pre></div></div>

<p>再看 Block 调用部分源代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">blk</span><span class="p">();</span>
</code></pre></div></div>

<p>这部分可转换为以下源代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>
</code></pre></div></div>

<p>去掉转换部分：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(*blk-&gt;impl.FuncPtr)(blk);
</code></pre></div></div>

<p>这就是简单地使用函数指针调用函数。由 Block 语法转换的 <code class="highlighter-rouge">__main_block_func_0</code> 函数的指针被赋值给成员变量 FuncPtr 中。另外说明了，<code class="highlighter-rouge">__main_block_func_0</code> 函数的参数 <code class="highlighter-rouge">__cself</code> 指向 Block 值。在调用该函数的源代码中可以看出 Block 正式作为参数进行了传递。</p>

<p>至此总算是摸清了 Block 的实质，不过之前跳过没有说明的 <code class="highlighter-rouge">_NSConcreteStackBlock</code> 到底是什么。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>isa = &amp;_NSConcreteStackBlock; 
</code></pre></div></div>

<p>将 Block 指针赋给 Block 的结构体成员变量 isa。为了理解它，首先要理解 Objective-C 类和对象的实质。其实，<strong>所谓 Block 就是 Objective-C 对象</strong>。</p>

<h3 id="32-截获自动变量值">3.2 截获自动变量值</h3>

<div class="language-objectivec highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="err">@autoreleasepool</span> <span class="p">{</span>
        
        <span class="kt">int</span> <span class="n">dmy</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="s">"val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        
        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);};</span>
        
        <span class="n">blk</span><span class="p">();</span>
        
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>通过 clang 转换可得：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  
  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_fmt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">fmt</span><span class="p">(</span><span class="n">_fmt</span><span class="p">),</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// bound by copy</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by copy</span>
<span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span> 

        <span class="kt">int</span> <span class="n">dmy</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="s">"val = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>

        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Block 语法表达式中使用的自动变量被作为成员变量追加到了 <code class="highlighter-rouge">__main_block_impl_0</code>结构体中。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">__main_block_impl_0</code> 结构体内声明的成员变量类型与自动变量类型完全相同（只有在 Block 语法表达式中使用的自动变量才会被追加）。<strong>Block 的自动变量捕获只针对 Block 使用的自动变量</strong>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_fmt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">fmt</span><span class="p">(</span><span class="n">_fmt</span><span class="p">),</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div>

<p>在初始化结构体时，根据传递给构造函数的参数对自动变量追加的成员变量进行初始化。以下通过构造函数调用确认其参数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> 
  <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
</code></pre></div></div>

<p>使用执行 Block 语法时的自动变量 fmt 和 val 来初始化 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例。即在该源代码中，<code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例的初始化如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>impl.isa = &amp;_NSConcreteStackBlock;
impl.Flags = 0;
impl.FuncPtr = __main_block_func_0;
Desc = &amp;__main_block_desc_0_DATA;
fmt = "val = %d\n";
val = 10;
</code></pre></div></div>

<p>由此可知，在 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例（即Block） 中，自动变量值被捕获。</p>

<p>下面再看一下使用 Block 的匿名函数的实现。最初源代码的 Block 语法如下所示：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">^</span><span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);}</span>
</code></pre></div></div>

<p>该源代码可转换以下函数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">fmt</span><span class="p">;</span> <span class="c1">// bound by copy</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by copy</span>
	<span class="n">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在转换后的源代码中，截获到 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例的成员变量上的自动变量，这些变量在 Block 语法表达式之前被声明定义。因此，原来的源代码表达式无需改动便可使用截获的自动变量值执行。</p>

<p>总的来说，所谓“截获自动变量值”意味着在执行 Block 语法时，Block 语法表达式所使用的自动变量值被保存到 Block 的结构体实例（即Block自身）中。需要注意的是，Block 不能直接使用 C 语言数组类型的自动变量。</p>

<h3 id="33-__block-说明符">3.3 __block 说明符</h3>

<p>Block 中所使用的被截获自动变量就如“带有自动变量值的匿名函数”所说，仅截获自动变量的值。Block 中使用自动变量后，在 Block 的结构体实例中重写该自动变量也不会改变原先截获的自动变量。</p>

<p>在 C 语言中有个一个变量允许 Block 改写值：</p>

<ul>
  <li>静态变量</li>
  <li>静态全局变量</li>
  <li>全局变量</li>
</ul>

<div class="language-objectivec highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">global_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">static_global_val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="err">@autoreleasepool</span> <span class="p">{</span>
        
        <span class="k">static</span> <span class="kt">int</span> <span class="n">static_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        
        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">global_val</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">static_global_val</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">static_val</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">};</span>
        
        <span class="n">blk</span><span class="p">();</span>
        
        <span class="n">printf</span><span class="p">(</span><span class="s">"global_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">global_val</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"static_global_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">static_global_val</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"static_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">static_val</span><span class="p">);</span>
        
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该源代码转换后如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">global_val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">static_global_val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">static_val</span><span class="p">;</span>
  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">_static_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">static_val</span><span class="p">(</span><span class="n">_static_val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">static_val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">static_val</span><span class="p">;</span> <span class="c1">// bound by copy</span>

            <span class="n">global_val</span> <span class="o">*=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">static_global_val</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="p">(</span><span class="o">*</span><span class="n">static_val</span><span class="p">)</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span> 

        <span class="k">static</span> <span class="kt">int</span> <span class="n">static_val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">static_val</span><span class="p">));</span>

        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"global_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">global_val</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"static_global_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">static_global_val</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"static_val=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">static_val</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由此可见访问静态全局变量 <code class="highlighter-rouge">static_global_val</code> 和全局变量 <code class="highlighter-rouge">global_val</code> 与转换前完全相同。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">static_val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">static_val</span><span class="p">;</span> <span class="c1">// bound by copy</span>

						<span class="p">...</span>
            <span class="p">(</span><span class="o">*</span><span class="n">static_val</span><span class="p">)</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>对于静态变量 <code class="highlighter-rouge">static_val</code>, 使用静态变量 <code class="highlighter-rouge">static_val</code>的指针对其进行访问。将静态变量 <code class="highlighter-rouge">static_val</code> 的<strong>指针</strong>传递给 <code class="highlighter-rouge">__main_block_impl_0</code>结构体的构造函数并保存。</p>

<p>静态变量的这种方法似乎也适用于自动变量的访问。但为什么没有这么做呢？</p>

<p>实际上，在由 Block 语法生成的值 Block 上，可以存有超过其变量作用域的被截获对象的自动变量。变量作用域结束的同时，原来的自动变量被废弃，因此 Block 中超过变量作用于而存在的变量同静态变量一样，将不能通过指针访问原来的自动变量。</p>

<p>解决 Block 中不能保存值这一问题的第二种方法是使用 <strong>__block</strong> 说明符。在 C 语言中有以下存储域类说明符：</p>

<ul>
  <li>typedef</li>
  <li>extern</li>
  <li>static</li>
  <li>auto</li>
  <li>register</li>
</ul>

<p>__block 说明符类似于 static 、auto 和 register 说明符，它们用于指定将变量值设置到哪个存储域中。例如，auto 表示作为自动变量存储在栈中，static 表示作为静态变量存储在数据区中。</p>

<p>__block 使用如下：</p>

<div class="language-objectivec highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="err">@autoreleasepool</span> <span class="p">{</span>
        
        <span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;};</span>
        
        <span class="n">blk</span><span class="p">();</span>
        
        <span class="n">printf</span><span class="p">(</span><span class="s">"val=%d"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>转换后如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__Block_byref_val_0</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
<span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span> <span class="c1">// by ref</span>
  
  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by ref</span>
<span class="p">(</span><span class="n">val</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">),</span> <span class="n">__main_block_copy_0</span><span class="p">,</span> <span class="n">__main_block_dispose_0</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span> 

        <span class="c1">//__attribute__((__blocks__(byref))) __Block_byref_val_0 val = {(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10};</span>
        <span class="n">__Block_byref_val_0</span> <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
          <span class="mi">0</span><span class="p">,</span>
          <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> 
          <span class="mi">0</span><span class="p">,</span> 
          <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_val_0</span><span class="p">),</span> 
          <span class="mi">10</span>
        <span class="p">};</span>               
                        
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>

        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"val=%d"</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">));</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由以上源码可得变量 val 上附加了 __block 说明符之后：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="c1">// 经过转换</span>
<span class="k">struct</span> <span class="n">__Block_byref_val_0</span> <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span>
  <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span>
  <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_val_0</span><span class="p">),</span>
  <span class="mi">10</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">__block</code> 变量变为了结构体实例。<code class="highlighter-rouge">__block</code> 变量也同 Block 一样变成 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体类型的自动变量，即栈上生成的 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体实例。该变量初始化为10，且这个值也出现在结构体实例的初始化中，这意味着该结构体持有相当于原自动变量的成员变量。该结构体声明如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__Block_byref_val_0</span> <span class="p">{</span>
 <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
 <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>如同初始化时的源代码，该结构体中最后的成员变量 val 是相当于原自动变量的成员变量，从它的名称也能看出这一点。</p>

<p>再来看给 __block 变量赋值的代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^{val = 1;}
</code></pre></div></div>

<p>转换如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// bound by ref</span>
	<span class="p">(</span><span class="n">val</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>刚刚在 Block 中向静态变量赋值时，使用了指向该静态变量的指针。而向 <code class="highlighter-rouge">__block</code> 变量赋值过程中，Block 的<code class="highlighter-rouge">__main_block_impl_0</code> 结构体实例持有指向 <code class="highlighter-rouge">__block</code> 变量 val 的 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体实例的指针。</p>

<p><code class="highlighter-rouge">__Block_byref_val_0</code> 结构体实例的成员变量 <code class="highlighter-rouge">__forwarding</code> 持有指向该实例自身的指针。通过成员变量 <code class="highlighter-rouge">__forwarding</code> 访问成员变量 val（成员变量 val 时该实例自身持有的变量，它相当于原自动变量）。</p>

<p><img src="assets/images/image-20200307190818557.png" alt="img" /></p>

<p>另外, <code class="highlighter-rouge">__block</code> 变量的 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体并不在 Block 中的 <code class="highlighter-rouge">__main_block_impl_0</code> 结构体中，这样做是为了在多个 Block 中使用 <code class="highlighter-rouge">__Block</code>变量。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__block</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        
<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk0</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;};</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk1</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;};</span>
</code></pre></div></div>

<p>Block 类型变量 blk0 和 blk1 访问 <code class="highlighter-rouge">__block</code> 变量 val。这部分代码转换后如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__Block_byref_val_0</span> <span class="n">val</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_val_0</span><span class="p">),</span> <span class="mi">10</span><span class="p">};</span>

<span class="n">blk0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">(</span>
  <span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>

<span class="n">blk1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__main_block_impl_1</span><span class="p">(</span>
  <span class="n">__main_block_func_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_1_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_val_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>
</code></pre></div></div>

<p>两个 Block 都是用了 <code class="highlighter-rouge">__Block_byref_val_0</code> 结构体实例 val 的指针。这样一来就可以从多个 Block 中使用同一个 <code class="highlighter-rouge">__block</code> 变量。当然，反过来从一个 Block 中使用多个 <code class="highlighter-rouge">__block</code> 变量也是可以的。只要增加 Block 的结构体成员变量与构造函数的参数，便可对应使用多个 <code class="highlighter-rouge">__block</code> 变量。</p>


    



<div class="post-tags">
  
    
    <a href="/hydeout/tags#objective-c">
    
      <span class="icon">
        <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
      </span>&nbsp;<span class="tag-name">Objective-C</span>
    </a>
  
</div>
  </div>

  
  <section class="comments">
    <h2>Comments</h2>
    
  <div id="disqus_thread">
    <button class="disqus-load" onClick="loadDisqusComments()">
      Load Comments
    </button>
  </div>
  <script>

  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW
  *  TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT:s
  *  https://disqus.com/admin/universalcode/#configuration-variables
  */
  var disqus_config = function () {
    this.page.url = "http://localhost:4000/hydeout/2020/03/01/block.html";
    this.page.identifier = "" ||
                           "http://localhost:4000/hydeout/2020/03/01/block.html";
  }
  function loadDisqusComments() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//hydeout.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  }
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a>.
  </noscript>



  </section>

  <section class="related">
  <h2>Related Posts</h2>
  <ul class="posts-list">
    
      <li>
        <h3>
          <a href="/hydeout/2020/01/17/flutter-widget.html">
            Widget 知识点
            <small>17 Jan 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/hydeout/2020/01/14/ios-map.html">
            iOS 开发舆图
            <small>14 Jan 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/hydeout/2020/01/13/swift-project-open-libs.html">
            🚀 Swift 项目中的开源库
            <small>13 Jan 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</section>

</div>

    </main>

    <!-- Optional footer content -->

  </body>
</html>
