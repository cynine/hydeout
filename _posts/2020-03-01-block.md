---
layout: post
title: Blocks
excerpt_separator: "<!--more-->"
categories:
  - iOS
tags:
  - Objective-C
last_modified_at: 2020-03-01T15:37:01-16:00
---
## Blocks 知识点
![img](assets/images/15835447426404.jpg)

## 前言
- block的原理是怎样的？本质是什么？
- __block的作用是什么？有什么使用注意点？
- block的属性修饰词为什么是copy？使用block有哪些使用注意？
- block在修改NSMutableArray，需不需要添加__block？

## 1. Blocks 概要
### 1.1 什么是 Blocks

Blocks 是 C 语言的扩充功能，即：**带有自动变量（局部变量）的匿名函数**。
- “带有自动变量”：为保证 Blocks 能正常访问外部的变量，Blocks 有一个自动捕获变量的机制。Blocks 能自动捕获（保存）在其内部使用到的外部自动变量（局部变量）的**瞬间值**。
- 匿名函数:不带有名称的函数。

其他语言中 Block 的名称

|  程序语言  |    Block 的名称    |
| :--------: | :----------------: |
| C + Blocks |       Block        |
| Smalltalk  |       Block        |
|    Ruby    |       Block        |
|    LISP    |       Block        |
|   Python   |       Lambda       |
|   C++ 11   |       Lambda       |
| JavaScript | Anonymous fucntion |

## 2. Block 模式
### 2.1 Block 语法
完整形式的 Block 语法与一般的 C 语言函数定义相比，仅有两点不同：
1. 没有函数名: 因为 Block 是匿名函数。
2. 带有“\^” （插入记号，caret）记号: 因为 OS X、iOS 应用程序的源代码中将大量使用 Block，所以插入该记好便于查找。

Block 声明语法:
     
```
^ 返回值类型 参数列表 表达式

e.g:
^int (int count) { return count + 1; };
```
Block 语法的简化：

```
1. 省略返回值类型（表达式含有 return 语句时，其返回值类型必定与 return 返回值的类型一致）

^ 参数列表 表达式

e.g:
^(int count) { return count + 1; };

2. 省略返回值类型和参数列表

^表达式

e.g:
^{ return count + 1 };
```
### 2.2 Block 类型变量

Block 语法但从记述方式来看，除了没有名称和带有“\^”以外，其他的都与 C 语言函数定义相同。在定义 C 语言函数时，可以将定义函数的地址赋值给函数指针变量中。

```c
int func(int count)
{
    return count + 1;
}
int (*funcptr)(int) = &func;
```

在 Block 的语法下，可将 Block 语法赋值给声明为 Block 类型的变量中。即源代码中一旦使用 Block 语法就相当于生成了可赋值给 Block 类型变量的“值”。在 Blocks 中，“Block” 既指源代码中的 Block 语法，也指由 Block 语法所生成的值。
声明 Block 类型变量：

```c
int (^blk)(int);
```
与前面对比使用函数指针的源代码对比，声明 Block 类型变量仅仅是将声明函数指针类型变量的 “*” 变成了 “\^”。该 Block 类型变量的与一般的 C 语言变量完成相同，可做为以下用途使用:
- 自动变量
- 函数参数
- 静态变量
- 静态全局变量
- 全局变量
使用 Block 语法将 Block 赋值为 Block 类型变量:

```c
int (^blk)(int) = ^(int count) { return count + 1; };
```
- 由 Block 类型变量向 Block 类型变量赋值：

```c
int (^blk1)(int) = blk;

int (^blk2)(int);
blk2 = blk1;
```
- 将 Block 类型变量作为函数参数使用：

```c
void func(int (^blk)(int) {}
```
- 将 Block 作为函数的返回值返回：

```c
int (^func())(int)
{
    return ^(int count){return count + 1;};
}
```
- 使用 `typedef` 简化上述操作：

```c
typedef int (^blk_t)(int);

/* 原来的记述方式 
void func(int (^blk)(int))
*/

简化为：
void func(blk_t blk) {}

/* 原来的记述方式
int (^func()(int))
*/

简化为：
blk_t func()
```
将赋值给 Block 类型变量中的 Block 方法的调用与使用函数指针类型变量调用函数的方法几乎完全相同：
- 调用函数指针类型变量:

```c
int result = (*funcptr)(10);
```
- 调用 Block 类型变量:

```c
int result = blk(10);
```
Block 类型变量调用 Block 与 C 语言通常的函数调用没有区别。在函数参数重使用 Block 类型变量并在函数中执行 Block 的例子:

```c
int func(blk_t blk, int rate)
{
    return blk(rete);
}
```
在 Objective-C 中方法使用:

```objectivec
- (int)methodUsingBlock:(blk_t)blk rete:(int)rete
{
    return blk(rete);
}
```
Block 类型变量可完全像通常的 C 语言变量一样使用，因此也可以使用之乡 Block 类型变量的指针，即 Block 的指针类型变量:

```c
typedef int (^blk_t)(int);

blk_t blk = ^(int count){return count + 1; };

blk_t *blkprt = &blk;

(*blkptr)(10);
```
### 2.3 截获自动变量值
“带有自动变量值”在 Blocks 中表现为“截获自动变量值”。截获自动变量值的实例如下:

```c
int main() 
{
    int dmy = 256;
    int val = 10;
    const char *fmt = "val = %d\n";
    void (^blk)(void) = ^{printf(fmt, val);};
    
    val = 2;
    fmt = "Thes values were changed. val = %d\n";
    
    bll();
    
    return 0
}

// val = 10
```
在该代码中， Block 语法的表达式使用的是它之前声明的自动变量 fmt 和 val。Blocks 中，Block 表达式截获所使用的自动变量值，即保存该自动变量的**瞬间值**。在执行 Block 语法后，即使改写 Block 中使用的自动变量的值也不会影响 Block 执行时变量的值。该 Block 语法执行时，字符串指针 “val=%d\n”被赋值到自动变量 fmt 中，int 值 10 被赋值到自动变量 val 中，因此这些值被保存（即被截获），从而在执行块时使用。**这就是自动变量值的捕获**。

### 2.4 __block 说明符
若想在 Block 语法的表达式中将赋给 Block 语法外声明的自动变量，需要在该自动变量上附加 `__block` 说明符。

```c
__block int val = 0;

void (^blk)(void) = ^{ val = 1; };

blk();

printf("val = %d\n", val);

// val = 1
```
使用附有 `__block` 说明符的自动变量可在 Block 中赋值，**该变量称为 __block 变量**。
## 3 Blocks 的实现
### 3.1 Block 的实质
通过 clang（LLVM 编译器）将 Objective-C 源代码转换为 C++ 的源代码：

```
clang -rewrite-objc 源代码文件名
```

```c
int main(int argc, const char *argv[])
{
    void (^ blk)(void) = ^{ printf("Block\n"); };

    blk();

    return 0;
}
```
通过 clang 将上述代码转换成 C++ 代码得：

```c
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) 
{
    printf("Block\n"); 
}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 
    0, 
    sizeof(struct __main_block_impl_0)
};

int main(int argc, const char *argv[])
{
    void (* blk)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));

    ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);

    return 0;
}
```

对比最初的源代码中的 Block 语法：

```c
^{printf("Block\n")};
```

转换为：

```c
static void __main_block_func_0(struct __main_block_impl_0 *__cself) 
{
    printf("Block\n"); 
}
```

如转换的源代码所示，通过 Blocks 使用的匿名函数实际上被作为简单的 C 语言函数来处理。另外，根据 Block 语法所属的函数名（此处为main）和该 Block 语法在该函数出现的顺序值（此处为0）来经 clang 变换的函数命名。

`__cself` 相当于 C++ 实例方法中指向实例自身的变量 `this`，或是 Objective-C 实例方法中指向对象自身的变量 `self`, 即参数 `__cself` 为指向 Block 值的变量。`__cself` 声明如下：

```c
struct __main_block_impl_0 *__cself
```

与 C++ 的 this 和 Objective-C 的 self 相同， 参数 \__cself 是 \__main_block_impl_0 结构题的指针。该结构体声明如下：

```c
struct __main_block_impl_0 {
  struct __block_impl impl; // 今后版本升级所需的区域以及函数指针
  struct __main_block_desc_0* Desc; // 其结构为今后版本升级所需要区域和 Block 的大小
};	
```

**__block_impl** 结构体的声明：

```c
struct __block_impl {
  void *isa; 
  int Flags;
  int Reserved;
  void *FuncPtr;
};
```

**__main_block_desc_0** 结构体声明：

```c
static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
}
```

再看 **__main_block_impl_0** 结构的构造函数：

```c
__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &_NSConcreteStackBlock; 
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
}
```

该构造函数的调用：

```c
void (* blk)(void) = 
  ((void (*)())&__main_block_impl_0(
     (void *)__main_block_func_0, &__main_block_desc_0_DATA));
```

去掉强制转化部分，可得：

```c
struct __mian_block_impl_0 tmp = __main_block_impl_0(
     __main_block_func_0, &__main_block_desc_0_DATA);

struct __main_block_impl_0 *blk = &tmp;
```

该代码将 `__main_block_impl_0` 结构体类型的自动变量，即栈上生成的 `__main_block_impl_0` 结构体实例的指针，赋值给 `__main_block_impl_0` 结构体指针类型的变量 `blk`。这部分最初的源代码为：

```c
void (^ blk)(void) = ^{ printf("Block\n"); };	
```

将 Block 语法生成的 Block 赋值给 Block 类型的变量 blk。等同于将 `__main_block_impl_0`  结构体实例的指针赋值给 `blk`。该源代码中的 Block 就是 `__main_block_impl_0` 结构体类型的自动变量，即栈上生成的 `__main_block_impl_0` 结构体实例。

由 `__main_block_impl_0` 结构体源代码可得，该结构体的构造函数的构造参数为：

```c
__main_block_impl_0(__main_block_func_0, &__main_block_desc_0_DATA);
```

第一个参数是由 Block 语法转换的 C 语言函数指针。第二个参数是作为静态全局变量初始化的 `__main_block_desc_0` 结构体实例指针。以下是 `__main_block_desc_0`  结构体实例的初始化部分代码：

```c
static struct __main_block_desc_0  __main_block_desc_0_DATA = { 
    0, 
    sizeof(struct __main_block_impl_0)
}
```

由此可知，该源代码使用 Block， 即 ``__main_block_impl_0`` 结构体的实例的大小，进行初始化。

栈上 `__main_block_impl_0` 结构体实例（即 Block）参数的初始化过程：

```c
// 展开 __main_block_impl_0 结构体的 __block_impl 结构体
struct __main_block_impl_0 {
  void *isa; 
  int Flags;
  int Reserved;
  void *FuncPtr;
  struct __main_block_desc_0* Desc; 
};	
```

该构造体根据构造函数会像下面这样进行初始化：

```c
isa = &_NSConcreteStackBlock; 
Flags = 0;
Reserved = 0;
FuncPtr = __main_block_func_0;
Desc = &__main_block_desc_0_DATA;
```

再看 Block 调用部分源代码：

```c
blk();
```

这部分可转换为以下源代码：

```c
((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);
```

去掉转换部分：

```
(*blk->impl.FuncPtr)(blk);
```

这就是简单地使用函数指针调用函数。由 Block 语法转换的 `__main_block_func_0` 函数的指针被赋值给成员变量 FuncPtr 中。另外说明了，`__main_block_func_0` 函数的参数 `__cself` 指向 Block 值。在调用该函数的源代码中可以看出 Block 正式作为参数进行了传递。

至此总算是摸清了 Block 的实质，不过之前跳过没有说明的 `_NSConcreteStackBlock` 到底是什么。

```
isa = &_NSConcreteStackBlock; 
```

将 Block 指针赋给 Block 的结构体成员变量 isa。为了理解它，首先要理解 Objective-C 类和对象的实质。其实，**所谓 Block 就是 Objective-C 对象**。

### 3.2 截获自动变量值

```objectivec
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        int dmy = 256;
        int val = 10;
        const char *fmt = "val = %d\n";
        
        void (^blk)(void) = ^{printf(fmt, val);};
        
        blk();
        
    }
    return 0;
}
```

通过 clang 转换可得：

```c
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  const char *fmt;
  int val;
  
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_fmt, int _val, int flags=0) : fmt(_fmt), val(_val) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  const char *fmt = __cself->fmt; // bound by copy
  int val = __cself->val; // bound by copy
printf(fmt, val);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        int dmy = 256;
        int val = 10;
        const char *fmt = "val = %d\n";

        void (*blk)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, fmt, val));

        ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);

    }
    return 0;
}
```

Block 语法表达式中使用的自动变量被作为成员变量追加到了 `__main_block_impl_0`结构体中。

```c
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  const char *fmt;
  int val;
};
```

`__main_block_impl_0` 结构体内声明的成员变量类型与自动变量类型完全相同（只有在 Block 语法表达式中使用的自动变量才会被追加）。**Block 的自动变量捕获只针对 Block 使用的自动变量**。

```c
__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_fmt, int _val, int flags=0) : fmt(_fmt), val(_val) { }
```

在初始化结构体时，根据传递给构造函数的参数对自动变量追加的成员变量进行初始化。以下通过构造函数调用确认其参数：

```c
void (*blk)(void) = 
  ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, fmt, val));
```

使用执行 Block 语法时的自动变量 fmt 和 val 来初始化 `__main_block_impl_0` 结构体实例。即在该源代码中，`__main_block_impl_0` 结构体实例的初始化如下：

```
impl.isa = &_NSConcreteStackBlock;
impl.Flags = 0;
impl.FuncPtr = __main_block_func_0;
Desc = &__main_block_desc_0_DATA;
fmt = "val = %d\n";
val = 10;
```

由此可知，在 `__main_block_impl_0` 结构体实例（即Block） 中，自动变量值被捕获。

下面再看一下使用 Block 的匿名函数的实现。最初源代码的 Block 语法如下所示：

```c
^{printf(fmt, val);}
```

该源代码可转换以下函数：

```c
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  const char *fmt = __cself->fmt; // bound by copy
  int val = __cself->val; // bound by copy
	printf(fmt, val);
}
```

在转换后的源代码中，截获到 `__main_block_impl_0` 结构体实例的成员变量上的自动变量，这些变量在 Block 语法表达式之前被声明定义。因此，原来的源代码表达式无需改动便可使用截获的自动变量值执行。

总的来说，所谓“截获自动变量值”意味着在执行 Block 语法时，Block 语法表达式所使用的自动变量值被保存到 Block 的结构体实例（即Block自身）中。需要注意的是，Block 不能直接使用 C 语言数组类型的自动变量。

### 3.3 __block 说明符

Block 中所使用的被截获自动变量就如“带有自动变量值的匿名函数”所说，仅截获自动变量的值。Block 中使用自动变量后，在 Block 的结构体实例中重写该自动变量也不会改变原先截获的自动变量。

在 C 语言中有个一个变量允许 Block 改写值：

- 静态变量
- 静态全局变量
- 全局变量

```objectivec
int global_val = 1;
static int static_global_val = 2;


int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        static int static_val = 3;
        
        void (^blk)(void) = ^{
            global_val *= 1;
            static_global_val *= 2;
            static_val *= 3;
        };
        
        blk();
        
        printf("global_val=%d\n", global_val);
        printf("static_global_val=%d\n", static_global_val);
        printf("static_val=%d\n", static_val);
        
    }
    return 0;
}
```

该源代码转换后如下：

```c
int global_val = 1;
static int static_global_val = 2;

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int *static_val;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int flags=0) : static_val(_static_val) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int *static_val = __cself->static_val; // bound by copy

            global_val *= 1;
            static_global_val *= 2;
            (*static_val) *= 3;
        }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        static int static_val = 3;

        void (*blk)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, &static_val));

        ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);

        printf("global_val=%d\n", global_val);
        printf("static_global_val=%d\n", static_global_val);
        printf("static_val=%d\n", static_val);

    }
    return 0;
}
```

由此可见访问静态全局变量 `static_global_val` 和全局变量 `global_val` 与转换前完全相同。

```c
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int *static_val = __cself->static_val; // bound by copy

						...
            (*static_val) *= 3;
        }
```

对于静态变量 `static_val`, 使用静态变量 `static_val`的指针对其进行访问。将静态变量 `static_val` 的**指针**传递给 `__main_block_impl_0`结构体的构造函数并保存。

静态变量的这种方法似乎也适用于自动变量的访问。但为什么没有这么做呢？

实际上，在由 Block 语法生成的值 Block 上，可以存有超过其变量作用域的被截获对象的自动变量。变量作用域结束的同时，原来的自动变量被废弃，因此 Block 中超过变量作用于而存在的变量同静态变量一样，将不能通过指针访问原来的自动变量。

解决 Block 中不能保存值这一问题的第二种方法是使用 **__block** 说明符。在 C 语言中有以下存储域类说明符：

-  typedef
- extern
- static
- auto
- register

__block 说明符类似于 static 、auto 和 register 说明符，它们用于指定将变量值设置到哪个存储域中。例如，auto 表示作为自动变量存储在栈中，static 表示作为静态变量存储在数据区中。

__block 使用如下：

```objectivec
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        __block int val = 10;
        void (^blk)(void) = ^{val = 1;};
        
        blk();
        
        printf("val=%d", val);
        
    }
    return 0;
}
```

转换后如下：

```c++
struct __Block_byref_val_0 {
  void *__isa;
__Block_byref_val_0 *__forwarding;
 int __flags;
 int __size;
 int val;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_val_0 *val; // by ref
  
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val->__forwarding) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_val_0 *val = __cself->val; // bound by ref
(val->__forwarding->val) = 1;}

static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->val, (void*)src->val, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->val, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        //__attribute__((__blocks__(byref))) __Block_byref_val_0 val = {(void*)0,(__Block_byref_val_0 *)&val, 0, sizeof(__Block_byref_val_0), 10};
        __Block_byref_val_0 val = {
          0,
          &val, 
          0, 
          sizeof(__Block_byref_val_0), 
          10
        };               
                        
        void (*blk)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_val_0 *)&val, 570425344));

        ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);

        printf("val=%d", (val.__forwarding->val));

    }
    return 0;
}
```

由以上源码可得变量 val 上附加了 __block 说明符之后：

```c
__block int val = 10;

// 经过转换
struct __Block_byref_val_0 val = {
	0,
  &val,
  0,
  sizeof(__Block_byref_val_0),
  10
};
```

`__block` 变量变为了结构体实例。`__block` 变量也同 Block 一样变成 `__Block_byref_val_0` 结构体类型的自动变量，即栈上生成的 `__Block_byref_val_0` 结构体实例。该变量初始化为10，且这个值也出现在结构体实例的初始化中，这意味着该结构体持有相当于原自动变量的成员变量。该结构体声明如下：

```c
struct __Block_byref_val_0 {
 void *__isa;
 __Block_byref_val_0 *__forwarding;
 int __flags;
 int __size;
 int val;
};
```

如同初始化时的源代码，该结构体中最后的成员变量 val 是相当于原自动变量的成员变量，从它的名称也能看出这一点。

再来看给 __block 变量赋值的代码：

```
^{val = 1;}
```

转换如下：

```c
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_val_0 *val = __cself->val; // bound by ref
	(val->__forwarding->val) = 1;
}
```

刚刚在 Block 中向静态变量赋值时，使用了指向该静态变量的指针。而向 `__block` 变量赋值过程中，Block 的`__main_block_impl_0` 结构体实例持有指向 `__block` 变量 val 的 `__Block_byref_val_0` 结构体实例的指针。  

`__Block_byref_val_0` 结构体实例的成员变量 `__forwarding` 持有指向该实例自身的指针。通过成员变量 `__forwarding` 访问成员变量 val（成员变量 val 时该实例自身持有的变量，它相当于原自动变量）。

![img](assets/images/image-20200307190818557.png)

另外, `__block` 变量的 `__Block_byref_val_0` 结构体并不在 Block 中的 `__main_block_impl_0` 结构体中，这样做是为了在多个 Block 中使用 `__Block`变量。

```c
__block int val = 10;
        
void (^blk0)(void) = ^{val = 0;};

void (^blk1)(void) = ^{val = 1;};
```

Block 类型变量 blk0 和 blk1 访问 `__block` 变量 val。这部分代码转换后如下：

```c
__Block_byref_val_0 val = {0, &val, 0, sizeof(__Block_byref_val_0), 10};

blk0 = &__main_block_impl_0(
  __main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_val_0 *)&val, 570425344));

blk1 = &__main_block_impl_1(
  __main_block_func_1, &__main_block_desc_1_DATA, (__Block_byref_val_0 *)&val, 570425344));
```

两个 Block 都是用了 `__Block_byref_val_0` 结构体实例 val 的指针。这样一来就可以从多个 Block 中使用同一个 `__block` 变量。当然，反过来从一个 Block 中使用多个 `__block` 变量也是可以的。只要增加 Block 的结构体成员变量与构造函数的参数，便可对应使用多个 `__block` 变量。

